
R version 3.6.0 (2019-04-26) -- "Planting of a Tree"
Copyright (C) 2019 The R Foundation for Statistical Computing
Platform: x86_64-w64-mingw32/x64 (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> pkgname <- "HaploBlocker"
> source(file.path(R.home("share"), "R", "examples-header.R"))
> options(warn = 1)
> options(pager = "console")
> base::assign(".ExTimings", "HaploBlocker-Ex.timings", pos = 'CheckExEnv')
> base::cat("name\tuser\tsystem\telapsed\n", file=base::get(".ExTimings", pos = 'CheckExEnv'))
> base::assign(".format_ptime",
+ function(x) {
+   if(!is.na(x[4L])) x[1L] <- x[1L] + x[4L]
+   if(!is.na(x[5L])) x[2L] <- x[2L] + x[5L]
+   options(OutDec = '.')
+   format(x[1L:3L], digits = 7L)
+ },
+ pos = 'CheckExEnv')
> 
> ### * </HEADER>
> library('HaploBlocker')
Loading required package: RandomFieldsUtils
'RandomFieldsUtils' sees OMP, AVX, SSE2, but not AVX2.
By default 'RandomFieldsUtils' is compiled with flag '-mavx' under your OS.
If you are sure that AVX2 is available, consider adding the flag '-march=native'
to 'PKG_CXXFLAGS' in the file src/Makefile.win and then recompile
'RandomFieldsUtils' .
Or: try adding flag '-mavx2' to 'PKG_CXXFLAGS'
> 
> base::assign(".oldSearch", base::search(), pos = 'CheckExEnv')
> base::assign(".old_wd", base::getwd(), pos = 'CheckExEnv')
> cleanEx()
> nameEx("coding")
> ### * coding
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: coding
> ### Title: Coding
> ### Aliases: coding codeSNPs decodeSNPs
> ### Keywords: models
> 
> ### ** Examples
> 
> animals <- 8
> snps <- 25
> ACGT <- c("A", "C", "G", "T")
> fixcoding(c(ACGT, "ANY"))
NULL
> (M <- matrix(nc=animals, sample(c(ACGT, "-", "+"), animals*snps, replace=TRUE)))
      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8]
 [1,] "A"  "C"  "C"  "T"  "G"  "+"  "T"  "A" 
 [2,] "T"  "C"  "+"  "+"  "C"  "A"  "A"  "-" 
 [3,] "A"  "+"  "+"  "-"  "C"  "G"  "T"  "-" 
 [4,] "C"  "A"  "C"  "T"  "-"  "+"  "C"  "-" 
 [5,] "-"  "T"  "-"  "T"  "C"  "G"  "-"  "T" 
 [6,] "G"  "A"  "C"  "A"  "-"  "+"  "C"  "+" 
 [7,] "+"  "T"  "+"  "-"  "T"  "G"  "C"  "+" 
 [8,] "C"  "G"  "+"  "-"  "-"  "G"  "C"  "T" 
 [9,] "G"  "+"  "+"  "+"  "T"  "T"  "G"  "+" 
[10,] "G"  "C"  "A"  "A"  "+"  "A"  "A"  "T" 
[11,] "A"  "C"  "G"  "A"  "A"  "A"  "C"  "C" 
[12,] "-"  "+"  "G"  "G"  "G"  "T"  "G"  "A" 
[13,] "-"  "T"  "+"  "+"  "C"  "C"  "G"  "G" 
[14,] "C"  "T"  "T"  "C"  "G"  "+"  "G"  "A" 
[15,] "+"  "T"  "+"  "C"  "G"  "A"  "+"  "+" 
[16,] "+"  "C"  "G"  "G"  "A"  "C"  "G"  "A" 
[17,] "C"  "T"  "A"  "+"  "-"  "G"  "-"  "T" 
[18,] "A"  "A"  "T"  "C"  "+"  "T"  "G"  "-" 
[19,] "-"  "+"  "-"  "T"  "+"  "A"  "A"  "A" 
[20,] "-"  "A"  "A"  "G"  "+"  "G"  "C"  "G" 
[21,] "A"  "T"  "A"  "-"  "T"  "-"  "T"  "T" 
[22,] "A"  "A"  "+"  "C"  "T"  "G"  "C"  "-" 
[23,] "+"  "+"  "T"  "C"  "A"  "T"  "C"  "T" 
[24,] "-"  "C"  "-"  "A"  "-"  "C"  "T"  "A" 
[25,] "-"  "G"  "-"  "G"  "-"  "A"  "-"  "A" 
> (CM <- codeSNPs(M))
           [,1]       [,2]       [,3]       [,4]       [,5]       [,6]
[1,]   50414145  289419314  339820868  876818500  554964020 1076110370
[2,]  570704196 1091842865 1075987266 1073889554  872550944  805508097
[3,]  272891972  809513025   54527028 1093812496 1145320196  587350577
[4,] 1073741824  536870912 1073741824  536870912 1073741824          0
           [,7]       [,8]
[1,]  808534289   71578691
[2,]  538059330 1125130304
[3,] 1107374355  872559664
[4,] 1073741824          0
attr(,"position")
[1]  0 24  4  0  0  8  1
> (decCM <- decodeSNPs(CM))
      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8]
 [1,] "A"  "C"  "C"  "T"  "G"  "@"  "T"  "A" 
 [2,] "T"  "C"  "@"  "@"  "C"  "A"  "A"  "@" 
 [3,] "A"  "@"  "@"  "@"  "C"  "G"  "T"  "@" 
 [4,] "C"  "A"  "C"  "T"  "@"  "@"  "C"  "@" 
 [5,] "@"  "T"  "@"  "T"  "C"  "G"  "@"  "T" 
 [6,] "G"  "A"  "C"  "A"  "@"  "@"  "C"  "@" 
 [7,] "@"  "T"  "@"  "@"  "T"  "G"  "C"  "@" 
 [8,] "C"  "G"  "@"  "@"  "@"  "G"  "C"  "T" 
 [9,] "G"  "@"  "@"  "@"  "T"  "T"  "G"  "@" 
[10,] "G"  "C"  "A"  "A"  "@"  "A"  "A"  "T" 
[11,] "A"  "C"  "G"  "A"  "A"  "A"  "C"  "C" 
[12,] "@"  "@"  "G"  "G"  "G"  "T"  "G"  "A" 
[13,] "@"  "T"  "@"  "@"  "C"  "C"  "G"  "G" 
[14,] "C"  "T"  "T"  "C"  "G"  "@"  "G"  "A" 
[15,] "@"  "T"  "@"  "C"  "G"  "A"  "@"  "@" 
[16,] "@"  "C"  "G"  "G"  "A"  "C"  "G"  "A" 
[17,] "C"  "T"  "A"  "@"  "@"  "G"  "@"  "T" 
[18,] "A"  "A"  "T"  "C"  "@"  "T"  "G"  "@" 
[19,] "@"  "@"  "@"  "T"  "@"  "A"  "A"  "A" 
[20,] "@"  "A"  "A"  "G"  "@"  "G"  "C"  "G" 
[21,] "A"  "T"  "A"  "@"  "T"  "@"  "T"  "T" 
[22,] "A"  "A"  "@"  "C"  "T"  "G"  "C"  "@" 
[23,] "@"  "@"  "T"  "C"  "A"  "T"  "C"  "T" 
[24,] "@"  "C"  "@"  "A"  "@"  "C"  "T"  "A" 
[25,] "@"  "G"  "@"  "G"  "@"  "A"  "@"  "A" 
> stopifnot(all(M == decCM || ((M == "-" || M == "+") && decCM == "@") ))
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("coding", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("colSumsEqualSNPs")
> ### * colSumsEqualSNPs
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: colSumsEqualSNPs
> ### Title: Columwise comparison of two genetic matrices
> ### Aliases: colSumsEqualSNPs
> ### Keywords: misc
> 
> ### ** Examples
> 
> fixcoding(0:1)
NULL
> require(RandomFieldsUtils)
> for (i in 1:10) {
+   animals <- sample(100, 1)
+   snps <- sample(30, 1)
+   v_snps <- sample(snps, 1)
+   start <- sample(snps - v_snps + 1, 1)
+ 
+   M <- matrix(nc=animals, sample(c(0,1), animals * snps, replace = TRUE))
+   V <- sample(c(0,1), v_snps, replace = TRUE)
+   Vext <- c(rep(NA, start-1), V, rep(NA, snps - v_snps - start + 1))
+   stopifnot(length(Vext) == nrow(M))
+   CM <- codeSNPs(M)
+   e <- colSumsEqualSNPs(CM, start, V)
+   Print(animals, snps, v_snps, start, e)
+   confirm(e, colSums(M == Vext, na.rm=TRUE))
+ }


animals [1] = 68
snps [1] = 7
v_snps [1] = 1
start [1] = 2
e [68] = 1 1 1 1 1 0 1 1 0 0 0 1 1 0 1 1 0 1 0 1 0 1 1 1 1 1 0 0 1 1 1 0 1 0 1 0 1 0 1 0 0 0 1 0 1 0 0 0 0 1 1 0 1 1 1 1 1 0 0 1 1 0 0 1 0 0 0 1
'e' and 'colSums(M == Vext, na.rm = TRUE)' are the same.


animals [1] = 99
snps [1] = 3
v_snps [1] = 2
start [1] = 1
e [99] = 1 1 1 1 2 2 2 2 2 1 0 1 0 1 0 2 1 1 1 0 1 0 0 1 1 1 2 1 0 1 1 1 2 1 2 1 2 1 1 1 0 2 0 1 1 2 1 1 1 0 1 1 0 1 2 1 0 1 0 1 1 2 0 1 1 1 1 1 2 2 0 0 2 1 2 0 1 1 0 1 1 2 1 2 1 2 1 1 0 1 2 0 2 2 0 1 2 1 2
'e' and 'colSums(M == Vext, na.rm = TRUE)' are the same.


animals [1] = 87
snps [1] = 6
v_snps [1] = 4
start [1] = 1
e [87] = 3 1 3 3 1 2 2 0 2 4 3 2 3 3 1 1 3 2 0 2 0 1 2 2 0 1 2 3 2 1 1 1 3 3 2 3 1 2 1 1 4 2 3 1 1 1 2 2 1 3 1 2 3 3 2 2 1 1 2 2 2 0 1 3 1 1 3 3 1 3 4 1 3 1 2 2 1 4 1 2 2 1 4 3 2 3 3
'e' and 'colSums(M == Vext, na.rm = TRUE)' are the same.


animals [1] = 23
snps [1] = 18
v_snps [1] = 2
start [1] = 7
e [23] = 1 2 0 1 1 1 0 1 0 1 1 1 1 2 1 2 1 2 2 2 1 0 1
'e' and 'colSums(M == Vext, na.rm = TRUE)' are the same.


animals [1] = 6
snps [1] = 28
v_snps [1] = 22
start [1] = 6
e [6] = 11 13 11 10 9 10
'e' and 'colSums(M == Vext, na.rm = TRUE)' are the same.


animals [1] = 97
snps [1] = 7
v_snps [1] = 6
start [1] = 2
e [97] = 3 4 1 4 4 3 4 4 2 3 4 3 2 4 4 4 2 3 3 3 4 2 1 5 4 4 1 5 3 2 3 2 4 5 3 2 3 3 3 4 4 2 4 4 5 0 4 3 3 5 4 4 3 4 4 2 3 4 1 1 3 2 2 5 1 5 4 2 3 2 1 4 2 3 5 3 3 2 2 3 4 2 4 2 3 2 4 3 1 5 3 6 4 2 3 2 3
'e' and 'colSums(M == Vext, na.rm = TRUE)' are the same.


animals [1] = 2
snps [1] = 17
v_snps [1] = 9
start [1] = 2
e [2] = 2 3
'e' and 'colSums(M == Vext, na.rm = TRUE)' are the same.


animals [1] = 74
snps [1] = 9
v_snps [1] = 7
start [1] = 2
e [74] = 4 5 4 3 5 3 4 2 2 5 5 3 3 2 4 3 3 4 4 3 5 2 6 1 3 4 3 4 5 5 1 3 7 4 3 1 3 3 4 5 4 3 2 3 3 5 3 5 3 2 2 3 5 3 5 4 4 4 3 3 5 2 2 3 4 4 2 2 6 3 2 0 4 4
'e' and 'colSums(M == Vext, na.rm = TRUE)' are the same.


animals [1] = 35
snps [1] = 13
v_snps [1] = 5
start [1] = 8
e [35] = 2 3 1 3 3 1 2 4 2 4 2 3 2 3 3 3 1 2 2 1 3 2 2 3 0 2 2 3 2 1 2 5 3 0 3
'e' and 'colSums(M == Vext, na.rm = TRUE)' are the same.


animals [1] = 24
snps [1] = 28
v_snps [1] = 3
start [1] = 12
e [24] = 1 1 1 0 1 1 2 1 1 0 0 0 1 1 3 2 1 0 0 3 2 2 3 2
'e' and 'colSums(M == Vext, na.rm = TRUE)' are the same.
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("colSumsEqualSNPs", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("factorSNPs")
> ### * factorSNPs
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: factorSNPs
> ### Title: Determines which codes are used in a given part of a SNP
> ###   sequence
> ### Aliases: factorSNPs
> ### Keywords: misc
> 
> ### ** Examples
> 
> require(RandomFieldsUtils)
> 
> fixcoding(0:1)
NULL
> for (i in 1:10) {
+   cat(i, "")
+   animals <- sample(500, 1)
+   snps <- sample(70, 1)
+   v_snps <- sample(snps - 1, 1)
+   start <- sample(snps - v_snps, 1)
+   end <- sample(start:snps, 1)
+   Print(animals, snps, start, end)
+   
+   M <- matrix(nc=animals, sample(c(0,1), animals * snps, replace = TRUE))
+   M <- cbind(M, M)
+   M <- M[, sample(ncol(M)), drop=FALSE]
+   ##  print(M)
+   CM <- codeSNPs(M)
+   f <- factorSNPs(CM, start, end)
+   ff <- unique(M[start:end, ,drop=FALSE], MARGIN = 2)
+   ##
+   stopifnot(ncol(ff) == length(attr(f, "where.to.find")))
+   stopifnot(ncol(ff) == length(attr(f, "where.to.find")))
+   stopifnot(all(ff == M[start:end, attr(f, "where.to.find")]))
+ }
1 

animals [1] = 324
snps [1] = 39
start [1] = 34
end [1] = 38
2 

animals [1] = 378
snps [1] = 67
start [1] = 26
end [1] = 67
3 

animals [1] = 403
snps [1] = 55
start [1] = 21
end [1] = 55
4 

animals [1] = 61
snps [1] = 9
start [1] = 6
end [1] = 6
5 

animals [1] = 193
snps [1] = 63
start [1] = 34
end [1] = 52
6 

animals [1] = 69
snps [1] = 68
start [1] = 2
end [1] = 62
7 

animals [1] = 382
snps [1] = 33
start [1] = 2
end [1] = 17
8 

animals [1] = 342
snps [1] = 43
start [1] = 2
end [1] = 39
9 

animals [1] = 487
snps [1] = 31
start [1] = 5
end [1] = 13
10 

animals [1] = 323
snps [1] = 12
start [1] = 3
end [1] = 4
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("factorSNPs", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("fixcoding")
> ### * fixcoding
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: fixcoding
> ### Title: Determination of Coding
> ### Aliases: fixcoding
> ### Keywords: misc
> 
> ### ** Examples
> 
> fixcoding(0:1)
NULL
> 
> animals <- 8
> snps <- 25
> (M <- matrix(nc=animals, sample(0:1, animals*snps, replace=TRUE)))
      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8]
 [1,]    0    0    1    1    1    0    1    1
 [2,]    1    1    0    1    1    0    0    1
 [3,]    0    0    1    0    1    1    0    1
 [4,]    0    0    1    0    0    1    0    1
 [5,]    1    1    0    1    0    0    0    0
 [6,]    0    1    0    1    0    0    1    1
 [7,]    0    1    1    1    0    0    1    0
 [8,]    0    0    1    0    1    1    1    0
 [9,]    1    1    1    0    0    0    1    0
[10,]    1    0    0    0    0    1    1    0
[11,]    0    0    0    1    0    0    0    0
[12,]    0    1    1    0    0    1    0    1
[13,]    0    0    1    1    0    1    0    0
[14,]    0    1    1    0    1    1    1    1
[15,]    0    1    1    1    1    0    0    0
[16,]    1    1    1    0    1    1    0    0
[17,]    1    1    1    0    1    0    1    1
[18,]    1    0    0    1    0    0    0    0
[19,]    1    1    1    1    1    1    0    1
[20,]    0    1    1    0    1    0    1    1
[21,]    0    1    1    0    1    1    0    1
[22,]    0    1    1    0    1    1    0    0
[23,]    0    1    0    1    0    1    1    1
[24,]    0    0    0    1    0    0    0    0
[25,]    0    0    0    0    1    0    0    0
> (CM <- codeSNPs(M))
           [,1]       [,2]        [,3]       [,4]       [,5]      [,6]
[1,] 1220665344 1318567424 -1281377280 -836082944 -519586688 828190208
            [,7]       [,8]
[1,] -2017160704 -199968256
attr(,"position")
[1]  0 24  1  0 24  8  1
> (decCM <- decodeSNPs(CM))
      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8]
 [1,]    0    0    1    1    1    0    1    1
 [2,]    1    1    0    1    1    0    0    1
 [3,]    0    0    1    0    1    1    0    1
 [4,]    0    0    1    0    0    1    0    1
 [5,]    1    1    0    1    0    0    0    0
 [6,]    0    1    0    1    0    0    1    1
 [7,]    0    1    1    1    0    0    1    0
 [8,]    0    0    1    0    1    1    1    0
 [9,]    1    1    1    0    0    0    1    0
[10,]    1    0    0    0    0    1    1    0
[11,]    0    0    0    1    0    0    0    0
[12,]    0    1    1    0    0    1    0    1
[13,]    0    0    1    1    0    1    0    0
[14,]    0    1    1    0    1    1    1    1
[15,]    0    1    1    1    1    0    0    0
[16,]    1    1    1    0    1    1    0    0
[17,]    1    1    1    0    1    0    1    1
[18,]    1    0    0    1    0    0    0    0
[19,]    1    1    1    1    1    1    0    1
[20,]    0    1    1    0    1    0    1    1
[21,]    0    1    1    0    1    1    0    1
[22,]    0    1    1    0    1    1    0    0
[23,]    0    1    0    1    0    1    1    1
[24,]    0    0    0    1    0    0    0    0
[25,]    0    0    0    0    1    0    0    0
> confirm(M, decCM)
'M' and 'decCM' are the same.
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("fixcoding", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("intersect")
> ### * intersect
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: intersect
> ### Title: Intersection of sets
> ### Aliases: intersect
> ### Keywords: misc
> 
> ### ** Examples
> 
> (a <- as.integer(sort(sample(20, 6))))
[1]  1  2  4  7 13 19
> (b <- as.integer(sort(sample(20,7))))
[1]  1  5 10 11 14 16 18
> confirm(intersect(a,b), base::intersect(a,b))
'intersect(a, b)' and 'base::intersect(a, b)' are the same.
> 
> a <- as.integer(sort(sample(2000, 600)))
> b <- as.integer(sort(sample(2000,700)))
> confirm(intersect(a,b), base::intersect(a,b))
'intersect(a, b)' and 'base::intersect(a, b)' are the same.
> print(system.time(for (i in 1:10^5) base::intersect(a,b)))
   user  system elapsed 
   3.85    0.00    3.84 
> print(system.time(for (i in 1:10^5) intersect(a,b))) ## factor 10 faster
   user  system elapsed 
   3.02    0.01    3.04 
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("intersect", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> ### * <FOOTER>
> ###
> cleanEx()
> options(digits = 7L)
> base::cat("Time elapsed: ", proc.time() - base::get("ptime", pos = 'CheckExEnv'),"\n")
Time elapsed:  7.28 0.04 7.34 NA NA 
> grDevices::dev.off()
null device 
          1 
> ###
> ### Local variables: ***
> ### mode: outline-minor ***
> ### outline-regexp: "\\(> \\)?### [*]+" ***
> ### End: ***
> quit('no')
