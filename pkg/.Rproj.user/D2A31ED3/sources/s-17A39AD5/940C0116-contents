library(HaploBlocker)
load(paste0("C:/Users/pook/Desktop/Genetic_Datasets/Batch3_KEPE/","KE","_DH_chromo",1,".RData"))
blocklist <- block_calculation(data)
se <- blocklist_startend(blocklist)

order <- 1:15
intensity <- 0.6
max_colors <- 15

library(randomcoloR)
set.seed(5)
coloring <- distinctColorPalette(max_colors)
coloring <- sample(coloring, max_colors)

{
tiff(filename="C:/Users/pook/Desktop/Coverart_HaploBlocker_1256_1631.tiff",
     width=1256, height = 1631, res = 300 )

  par(mar=c(0,0,0,0))
  
  type="snp"; orientation="snp"; include=TRUE; indi=NULL; min_to_plot = 5;
  intensity=0.5; add_sort=TRUE; max_step=500;
  snp_ori=22500; xlim =c(15000,30000)
  export_order=FALSE; import_order=FALSE;
  
  set.seed(6)
  coloring <- distinctColorPalette(max_colors)
  coloring <- sample(coloring, max_colors)
    
if(length(indi)==0){
  indi <- indi_calc(blocklist)
}

orientation_f <- orientation
se <- blocklist_startend(blocklist, type=type)
order <- NULL

if(length(orientation_f)==0){
  order <- 1:indi
} else if(orientation_f[1]=="front"){
  orientation <- 1:8
} else if(orientation_f[1]=="mid"){
  orientation <- 1:8 + ceiling(nrow(se)/2-3)
} else if(orientation_f[1]=="back"){
  orientation <- 1:8 + nrow(se) -8
} else if(orientation_f[1]=="snp"){
  if(length(snp_ori)==0){
    snp_ori <- mean(c(max(se), min(se)))
  }
  orientation <- which(((se[,1]<= snp_ori)+ (se[,2]>= snp_ori))==2)
} else{
  order <- orientation_f
}

if(length(orientation)>0 && import_order==FALSE){
  sorted <- orientation[1]
  orientation <- orientation[-1]
  while(length(orientation)>0){
    overlap <- numeric(length(orientation))
    actives <- blocklist[[sorted[length(sorted)]]][[6]]
    i1 <- 1
    for(index in orientation){
      nextone <- blocklist[[index]][[6]]
      overlap[i1] <- length(intersect(nextone,actives))/ length(nextone)
      i1 <- i1 + 1
    }
    sorted <- c(sorted, orientation[which.max(overlap)[1]])
    orientation <- orientation[-which.max(overlap)[1]]
  }
  orientation <- sorted
  
}
if(length(order)==0){
  if(include==TRUE){
    orientation <- c(orientation, 0)
  }
  for(index in orientation){
    pl <- length(order)
    if(index==0){
      order <- unique(c(order,1:indi))
      index <- ceiling(median(orientation[-length(orientation)]))
    } else{
      order <- unique(c(order,blocklist[[index]][[6]]))
    }
    
    if(add_sort==TRUE && length(order)>pl){
      if(pl>0){
        added <- order[-(1:pl)]
      } else{
        added <- order
      }
      groups <- list()
      groups[[1]] <- added
      for(step in 1:max_step){
        
        if(length(groups)<length(added)){
          if((index-step) >0 && length(intersect(blocklist[[index-step]][[6]], added))>0){
            new_groups <- list()
            for(group in 1:length(groups)){
              same <- base::intersect(groups[[group]], blocklist[[index-step]][[6]])
              rest <- base::intersect(groups[[group]], (1:indi)[-blocklist[[index-step]][[6]]])
              if(length(same)>0){
                new_groups[[length(new_groups)+1]] <- same
              }
              if(length(rest)>0){
                new_groups[[length(new_groups)+1]] <- rest
              }
              
            }
            groups <- new_groups
          }
          if((index+step) <=length(blocklist) && length(intersect(blocklist[[index+step]][[6]], added))>0){
            new_groups <- list()
            for(group in 1:length(groups)){
              same <- base::intersect(groups[[group]], blocklist[[index+step]][[6]])
              rest <- base::intersect(groups[[group]], (1:indi)[-blocklist[[index+step]][[6]]])
              if(length(same)>0){
                new_groups[[length(new_groups)+1]] <- same
              }
              if(length(rest)>0){
                new_groups[[length(new_groups)+1]] <- rest
              }
              
              
            }
            groups <- new_groups
          }
        }
        
      }
      if(pl>0){
        order <- c(order[(1:pl)],unlist(groups))
      } else{
        order <- c(unlist(groups))
      }
      
    }
  }
  
  
}

  plot(0,-1000,ylim=c(0,length(order))+c(20,-20), ylab="haplotype", xlab="SNP",
       cex.axis=1, cex.lab=1, xlim=xlim, axes=FALSE)



activ_colors <- numeric(length(blocklist))
for(index in (1:length(blocklist))[se[,1]<30000 & se[,2]>15000]){
  overlap <- duplicated(c(blocklist[[index]][[6]], order))[-(1:blocklist[[index]][[5]])]
  if(sum(overlap) >= min_to_plot){
    taken <- base::intersect(which(se[,1]<=se[index,2]), which(se[,2]>=se[index,1]))
    block_color <- sort(unique(c(0,activ_colors[taken])))
    if(length(setdiff(1:max_colors,block_color))==0){
      activ_colors[index] <- sample(1:max_colors,1)
    } else{
      activ_colors[index] <- sample(setdiff(1:max_colors,block_color),1)
    }

    for(index2 in which(overlap)){
      polygon(c(se[index,1], se[index,2], se[index,2], se[index,1]), index2-c(1,1,0,0),
              col=adjustcolor(coloring[activ_colors[index]],alpha.f=intensity), lty=0)
    }
  }
}

dev.off()

}


{
  tiff(filename="C:/Users/pook/Desktop/Coverart_HaploBlocker_2513_3263.tiff",
       width=2513, height = 3263, res = 300 )
  
  par(mar=c(0,0,0,0))
  
  type="snp"; orientation="snp"; include=TRUE; indi=NULL; min_to_plot = 5;
  intensity=0.5; add_sort=TRUE; max_step=500;
  snp_ori=22500; xlim =c(15000,30000)
  export_order=FALSE; import_order=FALSE;
  
  set.seed(6)
  coloring <- distinctColorPalette(max_colors)
  coloring <- sample(coloring, max_colors)
  
  if(length(indi)==0){
    indi <- indi_calc(blocklist)
  }
  
  orientation_f <- orientation
  se <- blocklist_startend(blocklist, type=type)
  order <- NULL
  
  if(length(orientation_f)==0){
    order <- 1:indi
  } else if(orientation_f[1]=="front"){
    orientation <- 1:8
  } else if(orientation_f[1]=="mid"){
    orientation <- 1:8 + ceiling(nrow(se)/2-3)
  } else if(orientation_f[1]=="back"){
    orientation <- 1:8 + nrow(se) -8
  } else if(orientation_f[1]=="snp"){
    if(length(snp_ori)==0){
      snp_ori <- mean(c(max(se), min(se)))
    }
    orientation <- which(((se[,1]<= snp_ori)+ (se[,2]>= snp_ori))==2)
  } else{
    order <- orientation_f
  }
  
  if(length(orientation)>0 && import_order==FALSE){
    sorted <- orientation[1]
    orientation <- orientation[-1]
    while(length(orientation)>0){
      overlap <- numeric(length(orientation))
      actives <- blocklist[[sorted[length(sorted)]]][[6]]
      i1 <- 1
      for(index in orientation){
        nextone <- blocklist[[index]][[6]]
        overlap[i1] <- length(intersect(nextone,actives))/ length(nextone)
        i1 <- i1 + 1
      }
      sorted <- c(sorted, orientation[which.max(overlap)[1]])
      orientation <- orientation[-which.max(overlap)[1]]
    }
    orientation <- sorted
    
  }
  if(length(order)==0){
    if(include==TRUE){
      orientation <- c(orientation, 0)
    }
    for(index in orientation){
      pl <- length(order)
      if(index==0){
        order <- unique(c(order,1:indi))
        index <- ceiling(median(orientation[-length(orientation)]))
      } else{
        order <- unique(c(order,blocklist[[index]][[6]]))
      }
      
      if(add_sort==TRUE && length(order)>pl){
        if(pl>0){
          added <- order[-(1:pl)]
        } else{
          added <- order
        }
        groups <- list()
        groups[[1]] <- added
        for(step in 1:max_step){
          
          if(length(groups)<length(added)){
            if((index-step) >0 && length(intersect(blocklist[[index-step]][[6]], added))>0){
              new_groups <- list()
              for(group in 1:length(groups)){
                same <- base::intersect(groups[[group]], blocklist[[index-step]][[6]])
                rest <- base::intersect(groups[[group]], (1:indi)[-blocklist[[index-step]][[6]]])
                if(length(same)>0){
                  new_groups[[length(new_groups)+1]] <- same
                }
                if(length(rest)>0){
                  new_groups[[length(new_groups)+1]] <- rest
                }
                
              }
              groups <- new_groups
            }
            if((index+step) <=length(blocklist) && length(intersect(blocklist[[index+step]][[6]], added))>0){
              new_groups <- list()
              for(group in 1:length(groups)){
                same <- base::intersect(groups[[group]], blocklist[[index+step]][[6]])
                rest <- base::intersect(groups[[group]], (1:indi)[-blocklist[[index+step]][[6]]])
                if(length(same)>0){
                  new_groups[[length(new_groups)+1]] <- same
                }
                if(length(rest)>0){
                  new_groups[[length(new_groups)+1]] <- rest
                }
                
                
              }
              groups <- new_groups
            }
          }
          
        }
        if(pl>0){
          order <- c(order[(1:pl)],unlist(groups))
        } else{
          order <- c(unlist(groups))
        }
        
      }
    }
    
    
  }
  
  plot(0,-1000,ylim=c(0,length(order))+c(20,-20), ylab="haplotype", xlab="SNP",
       cex.axis=1, cex.lab=1, xlim=xlim, axes=FALSE)
  
  
  
  activ_colors <- numeric(length(blocklist))
  for(index in (1:length(blocklist))[se[,1]<30000 & se[,2]>15000]){
    overlap <- duplicated(c(blocklist[[index]][[6]], order))[-(1:blocklist[[index]][[5]])]
    if(sum(overlap) >= min_to_plot){
      taken <- base::intersect(which(se[,1]<=se[index,2]), which(se[,2]>=se[index,1]))
      block_color <- sort(unique(c(0,activ_colors[taken])))
      if(length(setdiff(1:max_colors,block_color))==0){
        activ_colors[index] <- sample(1:max_colors,1)
      } else{
        activ_colors[index] <- sample(setdiff(1:max_colors,block_color),1)
      }
      
      for(index2 in which(overlap)){
        polygon(c(se[index,1], se[index,2], se[index,2], se[index,1]), index2-c(1,1,0,0),
                col=adjustcolor(coloring[activ_colors[index]],alpha.f=intensity), lty=0)
      }
    }
  }
  
  dev.off()
  
}

{
  tiff(filename="C:/Users/pook/Desktop/Coverart_HaploBlocker_314_408.tiff",
       width=314, height = 408, res = 300 )
  
  par(mar=c(0,0,0,0))
  
  type="snp"; orientation="snp"; include=TRUE; indi=NULL; min_to_plot = 5;
  intensity=0.5; add_sort=TRUE; max_step=500;
  snp_ori=22500; xlim =c(15000,30000)
  export_order=FALSE; import_order=FALSE;
  
  set.seed(6)
  coloring <- distinctColorPalette(max_colors)
  coloring <- sample(coloring, max_colors)
  
  if(length(indi)==0){
    indi <- indi_calc(blocklist)
  }
  
  orientation_f <- orientation
  se <- blocklist_startend(blocklist, type=type)
  order <- NULL
  
  if(length(orientation_f)==0){
    order <- 1:indi
  } else if(orientation_f[1]=="front"){
    orientation <- 1:8
  } else if(orientation_f[1]=="mid"){
    orientation <- 1:8 + ceiling(nrow(se)/2-3)
  } else if(orientation_f[1]=="back"){
    orientation <- 1:8 + nrow(se) -8
  } else if(orientation_f[1]=="snp"){
    if(length(snp_ori)==0){
      snp_ori <- mean(c(max(se), min(se)))
    }
    orientation <- which(((se[,1]<= snp_ori)+ (se[,2]>= snp_ori))==2)
  } else{
    order <- orientation_f
  }
  
  if(length(orientation)>0 && import_order==FALSE){
    sorted <- orientation[1]
    orientation <- orientation[-1]
    while(length(orientation)>0){
      overlap <- numeric(length(orientation))
      actives <- blocklist[[sorted[length(sorted)]]][[6]]
      i1 <- 1
      for(index in orientation){
        nextone <- blocklist[[index]][[6]]
        overlap[i1] <- length(intersect(nextone,actives))/ length(nextone)
        i1 <- i1 + 1
      }
      sorted <- c(sorted, orientation[which.max(overlap)[1]])
      orientation <- orientation[-which.max(overlap)[1]]
    }
    orientation <- sorted
    
  }
  if(length(order)==0){
    if(include==TRUE){
      orientation <- c(orientation, 0)
    }
    for(index in orientation){
      pl <- length(order)
      if(index==0){
        order <- unique(c(order,1:indi))
        index <- ceiling(median(orientation[-length(orientation)]))
      } else{
        order <- unique(c(order,blocklist[[index]][[6]]))
      }
      
      if(add_sort==TRUE && length(order)>pl){
        if(pl>0){
          added <- order[-(1:pl)]
        } else{
          added <- order
        }
        groups <- list()
        groups[[1]] <- added
        for(step in 1:max_step){
          
          if(length(groups)<length(added)){
            if((index-step) >0 && length(intersect(blocklist[[index-step]][[6]], added))>0){
              new_groups <- list()
              for(group in 1:length(groups)){
                same <- base::intersect(groups[[group]], blocklist[[index-step]][[6]])
                rest <- base::intersect(groups[[group]], (1:indi)[-blocklist[[index-step]][[6]]])
                if(length(same)>0){
                  new_groups[[length(new_groups)+1]] <- same
                }
                if(length(rest)>0){
                  new_groups[[length(new_groups)+1]] <- rest
                }
                
              }
              groups <- new_groups
            }
            if((index+step) <=length(blocklist) && length(intersect(blocklist[[index+step]][[6]], added))>0){
              new_groups <- list()
              for(group in 1:length(groups)){
                same <- base::intersect(groups[[group]], blocklist[[index+step]][[6]])
                rest <- base::intersect(groups[[group]], (1:indi)[-blocklist[[index+step]][[6]]])
                if(length(same)>0){
                  new_groups[[length(new_groups)+1]] <- same
                }
                if(length(rest)>0){
                  new_groups[[length(new_groups)+1]] <- rest
                }
                
                
              }
              groups <- new_groups
            }
          }
          
        }
        if(pl>0){
          order <- c(order[(1:pl)],unlist(groups))
        } else{
          order <- c(unlist(groups))
        }
        
      }
    }
    
    
  }
  
  plot(0,-1000,ylim=c(0,length(order))+c(20,-20), ylab="haplotype", xlab="SNP",
       cex.axis=1, cex.lab=1, xlim=xlim, axes=FALSE, axes=FALSE)
  
  
  
  activ_colors <- numeric(length(blocklist))
  for(index in (1:length(blocklist))[se[,1]<30000 & se[,2]>15000]){
    overlap <- duplicated(c(blocklist[[index]][[6]], order))[-(1:blocklist[[index]][[5]])]
    if(sum(overlap) >= min_to_plot){
      taken <- base::intersect(which(se[,1]<=se[index,2]), which(se[,2]>=se[index,1]))
      block_color <- sort(unique(c(0,activ_colors[taken])))
      if(length(setdiff(1:max_colors,block_color))==0){
        activ_colors[index] <- sample(1:max_colors,1)
      } else{
        activ_colors[index] <- sample(setdiff(1:max_colors,block_color),1)
      }
      
      for(index2 in which(overlap)){
        polygon(c(se[index,1], se[index,2], se[index,2], se[index,1]), index2-c(1,1,0,0),
                col=adjustcolor(coloring[activ_colors[index]],alpha.f=intensity), lty=0)
      }
    }
  }
  
  dev.off()
  
}
