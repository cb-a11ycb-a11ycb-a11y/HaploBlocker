coverage_list <- NULL
length_list <- NULL
rep100_list <- NULL
rep099_list <- NULL
founder100_list <- NULL
founder099_list <- NULL

for(run in 1:100){
  nindi <- 19
  library(MoBPS) # MoBPS is available at https://github.com/tpook92/
  # Alternatively use devtools::install_github("tpook92/MoBPS", subdir="pkg") to install
  
  # Generate a base-population with 50k SNPs, 3 Morgan genome, fully homozgyous individuals
  population <- creating.diploid(nindi=nindi, nsnp=50000, sex.quota = 0,
                                 chromosome.length = 3, dataset="homorandom")
  
  # Simulate matings between all founders
  population <- breeding.diploid(population, breeding.size=c(nindi*(nindi-1)/2,0),
                                 selection.size=c(nindi,0),
                                 breeding.all.combination = TRUE,
                                 mutation.rate=10^-4)
  
  # Simulation of 4 generations of random mating of the prior generation
  for(index in 1:4){
    population <- breeding.diploid(population, breeding.size=c(nindi*(nindi-1)/2,0),
                                   selection.size=c(nindi*(nindi-1)/2,0),
                                   same.sex.activ = TRUE, same.sex.sex=0,
                                   mutation.rate=10^-4)
  }
  
  # Simulation of 10 generations of self-fertilization
  for(index in 1:10){
    population <- breeding.diploid(population, breeding.size=c(nindi*(nindi-1)/2,0),
                                   selection.size=c(nindi*(nindi-1)/2,0),
                                   selfing.mating=TRUE, selfing.sex=0,
                                   max.offspring = 1, mutation.rate=10^-4)
  }
  
  # Derive haplotypes of last generation and founders
  haplos <- get.haplo(population, gen=16)
  founderhaplo <- get.haplo(population, gen=1)[,1:nindi*2]
  
  library(HaploBlocker)
  #blockl <- block_calculation(haplos, node_min = 5, edge_min = 5)
  blockl <- block_calculation(haplos, node_min = 5, edge_min = 5, target_coverage = 0.95)
  #blockl <- block_calculation(haplos, node_min = 5, edge_min = 5, target_coverage = 0.95, adaptive_mode = TRUE)
  
  se <- blocklist_startend(blockl)
  mean(se[,2]-se[,1])
  t <- coverage_test(blockl)
  mean(t)
  founder_info <- matrix(NA, nrow=length(blockl), ncol=6)
  representation <- matrix(0, nrow=nrow(haplos), ncol=ncol(founderhaplo))
  representation99 <- matrix(0, nrow=nrow(haplos), ncol=ncol(founderhaplo))
  
  for(index in 1:length(blockl)){
    start <- blockl[[index]][[2]]$snp
    end <- blockl[[index]][[3]]$snp
    concordance <- founderhaplo[start:end,]==blockl[[index]][[7]]$snp
    
    overlap <- colSums(concordance) / (end-start+1)
    founder_info[index, 1:2] <- c(which.max(overlap), max(overlap))
    founder_info[index, 3:4] <- c(which.max(overlap[-founder_info[index,1]]), max(overlap[-founder_info[index,1]]))
    if(founder_info[index,2]==1){
      representation[start:end, founder_info[index,1]] <- representation[start:end,founder_info[index,1]] +1
    }
    if(founder_info[index,2]>=0.99){
      representation99[start:end, founder_info[index,1]] <- representation99[start:end,founder_info[index,1]] +1
    }
    if(max(overlap)==1){
      founder_info[index,5] <- which.max(overlap)[1]
    }
    if(max(overlap)>=0.99){
      founder_info[index,6] <- which.max(overlap)[1]
    }
  }
  
  coverage_list <- c(coverage_list,mean(t))
  length_list <- c(length_list,mean(se[,2]-se[,1]+1))
  rep100_list <- c(rep100_list,mean(representation>0))
  rep099_list <- c(rep099_list,mean(representation99>0))
  founder100_list <- c(founder100_list,  mean(founder_info[,2]>=1))
  founder099_list <- c(founder099_list,   mean(founder_info[,2]>=0.99))
}
#save(file="Magic_default.RData", list=c("coverage_list", "length_list", "rep100_list",
                                        "rep099_list", "founder100_list", "founder099_list"))
save(file="Magic_target.RData", list=c("coverage_list", "length_list", "rep100_list",
"rep099_list", "founder100_list", "founder099_list"))
