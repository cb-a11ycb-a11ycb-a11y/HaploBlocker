{
    "collab_server" : "",
    "contents" : "/*\n Authors \n Martin Schlather, schlather@math.uni-mannheim.de\n\n Copyright (C) 2015 -- 2017 Martin Schlather\n\nThis program is free software; you can redistribute it and/or\nmodify it under the terms of the GNU General Public License\nas published by the Free Software Foundation; either version 3\nof the License, or (at your option) any later version.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program; if not, write to the Free Software\nFoundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.  \n*/\n\n#include <R_ext/Lapack.h>\n#include <General_utils.h> //#include <General_utils.h>\n#include \"xport_import.h\"\n\n\n#define SCALAR(A,B,C) Ext_scalarX(A,B,C, SCALAR_AVX)\n#define LINEAR(A,B,C,D) Ext_linearX(A,B,C,D,6)\n\n\nvoid strcopyN(char *dest, const char *src, int n) {\n  if (n > 1) {\n    n--; \n    strncpy(dest, src, n);\n  }\n  dest[n] = '\\0';\n}\n\nvoid AtA(double *a, int nrow, int ncol, double *C) {\n  // C =  A^T %*% A\n#ifdef DO_PARALLEL\n  //#pragma omp parallel for if (MULTIMINSIZE(ncol)) num_threads(2) schedule(dynamic) \n#pragma omp parallel for if (MULTIMINSIZE(ncol)) schedule(dynamic) \n#endif  \n  for (int i=0; i<ncol; i++) {\n    double \n      *A = a + i * nrow,\n      *B = A;\n    for (int j=i; j<ncol; j++, B+=nrow) {\n      C[i * ncol + j] = C[i + ncol * j] = SCALAR(A, B, nrow);\n    }\n  }\n}\n \n\nvoid xA(double *x, double*A, int nrow, int ncol, double *y) {\n  if (A == NULL) {\n    if (nrow != ncol || nrow <= 0) BUG;\n    MEMCOPY(y, x, sizeof(double) * nrow);\n  } else {\n    for (int i=0; i<ncol; i++) {\n      y[i] = SCALAR(x, A + i * nrow, nrow);\n    }\n  }\n}\n\nvoid xA_omp(double *x, double*A, int nrow, int ncol, double *y) {\n  if (A == NULL) {\n    if (nrow != ncol || nrow <= 0) BUG;\n    MEMCOPY(y, x, sizeof(double) * nrow);\n  } else {\n#ifdef DO_PARALLEL\n#pragma omp parallel for if (MULTIMINSIZE(ncol) && MULTIMINSIZE(nrow))\n#endif  \n   for (int i=0; i<ncol; i++) y[i] = SCALAR(x, A + i * nrow, nrow);\n  } \n} \n  \nvoid xA(double *x1, double *x2,  double*A, int nrow, int ncol, double *y1,\n\tdouble *y2) {\n  if (A == NULL) {\n    if (nrow != ncol || nrow <= 0) BUG;\n    MEMCOPY(y1, x1, sizeof(double) * nrow);\n    MEMCOPY(y2, x2, sizeof(double) * nrow);\n  } else {\n    double *a = A;\n    for (int i=0; i<ncol; i++, a += nrow) {\n      y1[i] = SCALAR(x1, a, nrow);\n      y2[i] = SCALAR(x2, a, nrow);\n    }\n  }\t\n}\n\n\nvoid Ax(double *A, double*x, int nrow, int ncol, double *y) {\n  if (A == NULL) {\n    if (nrow != ncol || nrow <= 0) BUG;\n    MEMCOPY(y, x, sizeof(double) * nrow);\n  } else {\n#ifdef DO_PARALLEL\n#pragma omp parallel for if (MULTIMINSIZE(ncol) && MULTIMINSIZE(nrow))\n    for (int j=0; j<nrow; j++) {\n      double dummy = 0.0;\n      int k = j;\n      for (int i=0; i<ncol; i++, k+=nrow) { \n\tdummy += A[k] * x[i];\n      }\n      y[j] = dummy;\n    }\n#else\n    for (int i=0; i<nrow; i++) y[i]=0.0;\n    for (int k=0, i=0; i<ncol; i++) { \n      for (int j=0; j<nrow; j++) {\n\ty[j] += A[k++] * x[i];\n      }\n    }\n#endif  \n  }\n}\n\n\nvoid Ax(double *A, double*x1, double*x2, int nrow, int ncol, double *y1,\n\tdouble *y2) {\n  if (A == NULL) {\n    if (nrow != ncol || nrow <= 0) BUG;\n    MEMCOPY(y1, x1, sizeof(double) * nrow);\n    MEMCOPY(y2, x2, sizeof(double) * nrow);\n  } else {\n    for (int i=0; i<nrow; i++) y1[i]=y2[i]=0.0;\n    for (int k=0, i=0; i<ncol; i++) { \n      for (int j=0; j<nrow; j++) {\n\ty1[j] += A[k] * x1[i];\n\ty2[j] += A[k++] * x2[i];\n      }\n    }\n  }\n}\n\n\ndouble XkCXtl(double *X, double *C, int nrow, int dim, int k, int l) {\n  // (k-th row of X) * C * (l-th row of X)\n  // X is nrow x dim matrix\n  // C is dim x dim matrix\n  double\n    *pX = X + k, \n    *pY = X + l, \n    result = 0.0;\n  int size = nrow * dim;\n  \n#ifdef DO_PARALLEL\n#pragma omp parallel for reduction(+:result)\n#endif\n  for (int j=0; j<size; j+=nrow) {\n    double scalar = 0.0;\n    int ci = j * dim;\n    for (int i=0; i<size; i+=nrow) scalar += pX[i] * C[ci++];\n    result += scalar * pY[j];\n  }\n  return result;\n}\n\n\nvoid XCXt(double *X, double *C, double *V, int nrow, int dim /* dim of C */) {\n  int size = nrow * dim;\n  double  \n    *endpX = X + nrow,\n    *dummy = (double*) MALLOC(sizeof(double) * size); // dummy = XC\n  if (dummy == NULL) ERR(\"XCXt: memory allocation error in XCXt\");\n \n#ifdef DO_PARALLEL\n#pragma omp parallel for \n#endif\n  for (double *pX = X; pX < endpX; pX++) {\n    double *pdummy = dummy + (pX - X);\n    for (int ci=0, cd=0; cd<size; cd+=nrow) {\n      double scalar = 0.0;\n      for (int i=0; i<size; i+=nrow) {\n        scalar += pX[i] * C[ci++];\n      }\n      pdummy[cd] = scalar;\n    }\n  }\n\n  // V = dummy X^t\n#ifdef DO_PARALLEL\n#pragma omp parallel for \n#endif\n  for (int rv=0; rv<nrow; rv++) {\n    for (int cv=rv; cv<nrow; cv++) {\n      double scalar=0.0;\n      for (int i=0; i<size; i+=nrow) {\n\tscalar += dummy[rv + i] * X[cv + i];\n     }\n      V[rv + cv * nrow] = V[cv + rv * nrow] = scalar;\n    }\n  }\n\n  UNCONDFREE(dummy);\n}\n\n\ndouble xUy(double *x, double *U, double *y, int dim) {\n  // U a symmetric matrix given by its upper triangular part\n  double xVy = 0.0;\n  int    dimM1 = dim - 1;\n#ifdef DO_PARALLEL\n#pragma omp parallel for if (MULTIMINSIZE(dim)) reduction(+:xVy) \n#endif  \n  for (int d=0; d<dim; d++) {\n    int i, \n      j = dim * d;\n    double dummy = 0.0;\n    for (i=0; i<=d; i++) dummy += x[i] * U[j++];\n    for (j += dimM1; i<dim; i++, j+=dim) dummy += x[i] * U[j];\n    xVy += dummy * y[d];\n  }\n  return xVy;\n}\n\n/*\n\n  // U a symmetric matrix given by its upper triangular part\n  assert(z != NULL);\n  int   dimM1 = dim - 1;\n#ifdef DO_PARALLEL\n#pragma omp parallel for if (MULTIMINSIZE(dim))\n#endif  \n  for (int d=0; d<dim; d++) {\n    double dummy;\n    int i,\n      j = dim * d;\n    for (dummy = 0.0, i=0; i<=d; i++) dummy += x[i] * U[j++];\n    for (j += dimM1; i<dim; i++, j+=dim) dummy += x[i] * U[j];\n    if (z!=NULL) z[d] = dummy;\n  }\n  double xVx;\n  SCALAR_PROD(z, x, dim, xVx);\n  return xVx;\n\n */\n\ndouble xUxz(double *x, double *U, int dim, double *z) {\n double xVx = 0.0;\n  int dimM1 = dim - 1;\n#ifdef DO_PARALLEL\n#pragma omp parallel for reduction(+:xVx)\n#endif\n  for (int d=0; d<dim; d++) {\n    int i, \n      j = dim * d;\n    double dummy = 0.0;\n    for (dummy = 0.0, i=0; i<=d; i++) dummy += x[i] * U[j++];\n    for (j += dimM1; i<dim; i++, j+=dim) dummy += x[i] * U[j];\n    if (z != NULL) z[d] = dummy;\n    xVx += dummy * x[d];\n  }\n  return xVx;\n}\n\ndouble xUx(double *x, double *U, int dim) {\n    return xUxz(x, U, dim, NULL);\n}\n\ndouble x_UxPz(double *x, double *U, double *z, int dim) {\n// x^t (Ux + z); U dreieckmatrix\n  double xVx = 0.0;\n  int    dimM1 = dim - 1;\n#ifdef DO_PARALLEL\n#pragma omp parallel for reduction(+:xVx)\n#endif\n  for (int d=0; d<dim; d++) {\n    int i,\n      j = dim * d;\n    double dummy = z[d];\n    for (i=0; i<=d; i++) dummy += x[i] * U[j++];\n    for (j += dimM1; i<dim; i++, j+=dim) dummy += x[i] * U[j];\n    xVx += dummy * x[d];\n  }\n  return xVx;\n}\n\n\n\nvoid matmult(double *a, double *b, double *c, int l, int m, int n) {\n// multiplying an lxm- and an mxn-matrix, saving result in C\n#ifdef DO_PARALLEL\n#pragma omp parallel for \n#endif\n   for (int i=0; i<l; i++) {\n     double *A = a + i,\n       *C = c + i;\n     for (int j=0; j<n; j++) {\n       double dummy = 0.0,\n\t *B = b + j * m;\n       for (int k=0; k<m; k++) dummy += A[k*l] * B[k];\n       C[j * l] = dummy;\n     }\n   }\n}\n\n\nvoid matmulttransposed(double *A, double *B, double *c, int m, int l, int n) {\n// multiplying t(A) and B with dim(A)=(m,l) and dim(B)=(m,n),\n// saving result in C\n#ifdef DO_PARALLEL\n#pragma omp parallel for \n#endif\n  for (int i=0; i<l; i++) {    \n    double *C = c + i,\n      *Aim = A + i * m;\n    for (int j=0; j<n; j++) C[j * l] = SCALAR(Aim, B + j * m, m);\n  }\n}\n\n\n\nvoid matmult_2ndtransp(double *a, double *B, double *c, int m, int l, int n) {\n// multiplying A and t(B) with dim(A)=(m,l) and dim(B)=(n, l),\n// saving result in C\n  int msq = m  * m;\n#ifdef DO_PARALLEL\n#pragma omp parallel for \n#endif\n  for (int i=0; i<l; i++) {\n    double *C = c + i,\n      *A = a + i;\n    for (int j=0; j<n; j++) {\n       double dummy = 0.0,\n\t *Bj = B + j;\n       for (int k=0; k<msq; k+=m) dummy += A[k] * Bj[k];\n       C[j*l] = dummy;\n    }\n  }\n}\n\n\n\nvoid matmult_tt(double *a, double *B, double *c, int m, int l, int n) {\n// calculating t(A B) with dim(A)=(m,l) and dim(B)=(m,n),\n// saving result in C\n#ifdef DO_PARALLEL\n#pragma omp parallel for \n#endif\n  for (int i=0; i<l; i++) {\n    double *A = a + i,\n      *C = c + i * l;\n    for (int j=0; j<n; j++) {\n      double dummy = 0.0,\n\t*Bjm = B + j * m;\n      for (int k=0; k<m; k++) dummy += A[k * l] * Bjm[k];\n      C[j] = dummy;\n    }\n  }\n}\n\n\n\nvoid Xmatmult(double *A, double *B, double *C, int l, int m, int n) {\n// multiplying an lxm- and an mxn-matrix, saving result in C\n#ifdef DO_PARALLEL\n#pragma omp parallel for \n#endif\n  for (int i=0; i<l; i++) {\n    for (int jl=i, jm=0, j=0; j<n; j++, jl+=l, jm+=m) {\n      double dummy = 0.0;\n      int endfor = jm + m;\n      for (int kl=i, k=jm; k<endfor; k++, kl+=l) dummy += A[kl] * B[k]; \n      C[jl] = dummy;\n    }\n  }\n}\n\nvoid Xmatmulttransposed(double *A, double *B, double *C, int m, int l, int n) {\n// multiplying t(A) and B with dim(A)=(m,l) and dim(B)=(m,n),\n// saving result in C\n#ifdef DO_PARALLEL\n#pragma omp parallel for \n#endif\n  for (int i=0; i<l; i++) {\n    int im = i * m;\n    for (int jl=i, jm=0, j=0; j<n; j++, jl+=l, jm+=m) {\n      double dummy = 0.0;\n      int endfor = im + m;\n      for (int jmk=jm, k=im; k<endfor; k++) dummy += A[k] * B[jmk++]; \n      C[jl] = dummy;\n    }\n  }\n}\n\n\n\ndouble *matrixmult(double *m1, double *m2, int dim1, int dim2, int dim3) {\n  double *m0 = (double*) MALLOC(sizeof(double) * dim1 * dim3);\n  matmult(m1, m2, m0, dim1, dim2, dim3);\n  return m0;\n}\n\n\nSEXP TooLarge(int *n, int l){\n#define nTooLarge 2 // mit op\n  const char *tooLarge[nTooLarge] = {\"size\", \"msg\"};\n  SEXP namevec, info;\n  PROTECT(info=allocVector(VECSXP, nTooLarge));\n  PROTECT(namevec = allocVector(STRSXP, nTooLarge));\n  for (int i=0; i<nTooLarge; i++)\n    SET_STRING_ELT(namevec, i, mkChar(tooLarge[i]));\n  setAttrib(info, R_NamesSymbol, namevec);\n  int i=0;\n  SET_VECTOR_ELT(info, i++, Int(n, l, l));\n  SET_VECTOR_ELT(info, i,\n\t\t mkString(\"too many elements - increase max.elements\"));\n  UNPROTECT(2);\n  return info;\n}\n\nSEXP TooSmall(){\n  SEXP namevec;\n  const char *msg = \"value has not been initialized\";\n  PROTECT(namevec = allocVector(STRSXP, 1));\n  SET_STRING_ELT(namevec, 0, mkChar(msg));\n  UNPROTECT(1);\n  return namevec;\n}\n\n\nSEXP Int(int *V, int n, int max) {\n  SEXP dummy;\n  if (V==NULL) return allocVector(INTSXP, 0);\n  if (n>max) return TooLarge(&n, 1);\n   if (n<0) return TooSmall();\n   PROTECT(dummy=allocVector(INTSXP, n));\n  for (int i=0; i<n; i++) INTEGER(dummy)[i] = V[i];\n  UNPROTECT(1);\n  return dummy;\n}\n\nSEXP Int(int* V, int n) {\n  return Int(V, n, MAXINT);\n}\n\n\nSEXP Logic(bool* V, int n, int max) {\n  SEXP dummy;\n  if (V==NULL) return allocVector(VECSXP, 0);\n  if (n>max) return TooLarge(&n, 1);\n  if (n<0) return TooSmall();\n  PROTECT(dummy=allocVector(LGLSXP, n));\n  for (int i=0; i<n; i++) LOGICAL(dummy)[i] = V[i];\n  UNPROTECT(1);\n  return dummy;\n}\nSEXP Logic(bool* V, int n) {\n  return Logic(V, n, MAXINT);\n}\n\nSEXP Num(double* V, int n, int max) {\n  SEXP dummy;\n  if (V==NULL) return allocVector(REALSXP, 0);\n  if (n>max) return TooLarge(&n, 1);\n   if (n<0) return TooSmall();\n  PROTECT(dummy=allocVector(REALSXP, n));\n  for (int i=0; i<n; i++) REAL(dummy)[i] = V[i];\n  UNPROTECT(1);\n  return dummy;\n}\nSEXP Num(double* V, int n) {\n  return Num(V, n, MAXINT);\n}\n\nSEXP Result(double* V, int n, int max) {\n  SEXP dummy;\n  if (V==NULL) return allocVector(REALSXP, 0);\n  if (n>max) return TooLarge(&n, 1);\n   if (n<0) return TooSmall();\n PROTECT(dummy=allocVector(REALSXP, n));\n  for (int i=0; i<n; i++) REAL(dummy)[i] = (double) V[i];\n  UNPROTECT(1);\n  return dummy;\n}\n\nSEXP Result(double* V, int n) {\n  return Result(V, n, MAXINT);\n}\n\nSEXP Char(const char **V, int n, int max) {\n  SEXP dummy;\n  if (V==NULL) return allocVector(STRSXP, 0);\n  if (n>max) return TooLarge(&n, 1);\n   if (n<0) return TooSmall();\n   PROTECT(dummy=allocVector(STRSXP, n));\n   for (int i=0; i<n; i++){\n     SET_STRING_ELT(dummy, i, mkChar(V[i]));  \n   }\n  UNPROTECT(1);\n  return dummy;\n}\n\nSEXP Char(const char **V, int n) {\n  return Char(V, n, MAXINT);\n}\n\nSEXP Mat(double* V, int row, int col, int max) {\n  if (V==NULL) return allocMatrix(REALSXP, 0, 0);\n  int n = row * col;\n  if (n>max) {\n    int nn[2];\n    nn[0] = row;\n    nn[1] = col;\n    return TooLarge(nn, 2);\n  }\n  SEXP dummy;\n  PROTECT(dummy=allocMatrix(REALSXP, row, col));\n  for (int i=0; i<n; i++) REAL(dummy)[i] = V[i];\n  UNPROTECT(1);\n  return dummy;\n}\n\nSEXP Mat(double* V, int row, int col) {\n  return Mat(V, row, col, MAXINT);\n}\n\n\nSEXP Mat_t(double* V, int row, int col, int max) {\n  if (V==NULL) return allocMatrix(REALSXP, 0, 0);\n  int n = row * col;\n  if (n>max) {\n    int nn[2];\n    nn[0] = row;\n    nn[1] = col;\n    return TooLarge(nn, 2);\n  }\n  SEXP dummy;\n  PROTECT(dummy=allocMatrix(REALSXP, row, col));\n  for (int k=0, j=0; j<col; j++) {\n     for (int i=0; i<row; i++) {\n      REAL(dummy)[k++] = V[j + col * i];\n    }\n  }\n  UNPROTECT(1);\n  return dummy;\n}\n\nSEXP Mat_t(double* V, int row, int col) {\n  return Mat_t(V, row, col, MAXINT);\n}\n\n\nSEXP MatString(char **V, int row, int col, int max) {\n  if (V==NULL) return allocMatrix(STRSXP, 0, 0);\n  int n = row * col;\n  if (n>max) {\n    int nn[2];\n    nn[0] = row;\n    nn[1] = col;\n    return TooLarge(nn, 2);\n  }\n  SEXP dummy;\n  PROTECT(dummy=allocMatrix(STRSXP, row, col));\n  for (int k=0; k<n; k++)\n    SET_STRING_ELT(dummy, k, mkChar(V[k]));\n  UNPROTECT(1);\n  return dummy;\n}\n\nSEXP MatString(char** V, int row, int col) {\n  return MatString(V, row, col, MAXINT);\n}\n\nSEXP MatInt(int* V, int row, int col, int max) {\n  if (V==NULL) return allocMatrix(INTSXP, 0, 0);\n  int n = row * col;\n  if (n>max) {\n    int nn[2];\n    nn[0] = row;\n    nn[1] = col;\n    return TooLarge(nn, 2);\n  }\n  SEXP dummy;\n  PROTECT(dummy=allocMatrix(INTSXP, row, col));\n  for (int i=0; i<n; i++) INTEGER(dummy)[i] = V[i];\n  UNPROTECT(1);\n  return dummy;\n}\n\nSEXP MatInt(int* V, int row, int col) {\n  return MatInt(V, row, col, MAXINT);\n}\n\nSEXP Array3D(double** V, int depth, int row, int col, int max) {\n  if (V==NULL) return alloc3DArray(REALSXP, 0, 0, 0);\n  int\n    m = row * col,\n    n = row * col * depth;\n  if (n>max) {\n    int nn[3];\n    nn[0] = row;\n    nn[1] = col;\n    nn[2] = depth;\n    return TooLarge(nn, 3);\n  }\n  SEXP dummy;\n  PROTECT(dummy=alloc3DArray(REALSXP, depth, row, col));\n  for (int j=0; j<depth; j++) {\n    for (int i=0; i<m; i++) {\n      REAL(dummy)[j*m+i] = V[j][i];\n    }\n  }\n  UNPROTECT(1);\n  return dummy;\n}\n\nSEXP Array3D(double** V, int depth, int row, int col) {\n  return Array3D(V, depth, row, col, MAXINT);\n}\n\n\n\n\n//static int ZZ = 0;\nusr_bool UsrBool(SEXP p, char *name, int idx) {\n  double dummy = Real(p, name, idx);\n  if (dummy == 0.0) return False;\n  else if (dummy == 1.0) return True;\n  else if (ISNAN(dummy)) return Nan;\n  ERR2(\"invalid value (%d) for boolean variable '%s'.\", (int) dummy, name);\n}\n\n\n\n\nSEXP String(char *V) {\n  SEXP str;\n  PROTECT(str = allocVector(STRSXP, 1)); \n  SET_STRING_ELT(str, 1, mkChar(V));\n  UNPROTECT(1);\n  return str;\n}\n\nSEXP String(char V[][MAXCHAR], int n, int max) {\n  SEXP str;\n  if (V==NULL) return allocVector(STRSXP, 0);\n  if (n>max) return TooLarge(&n, 1);\n  if (n<0) return TooSmall();\n  PROTECT(str = allocVector(STRSXP, n)); \n  for (int i=0; i<n; i++) {\n    SET_STRING_ELT(str, i, mkChar(V[i]));\n  }\n  UNPROTECT(1);\n  return str;\n}\n\n\nSEXP String(int *V, const char * List[], int n, int endvalue) {\n  SEXP str;\n  if (V==NULL || n <= 0) return allocVector(STRSXP, 0);\n  int k;\n  for (k=0; k<n; k++) {\n    if (V[k] == endvalue) break;\n  }\n  PROTECT(str = allocVector(STRSXP, k)); \n  for (int i=0; i<k; i++) {\n    SET_STRING_ELT(str, i, mkChar(List[V[i]]));\n  }\n  UNPROTECT(1);\n  return str;\n}\n\n//static int ZZ = 0;\ndouble Real(SEXP p, char *name, int idx) {\n  //  {printf(\"%s type=%d \\n\", name,TYPEOF(p));}\n  if (p != R_NilValue) {\n    assert(idx < length(p));\n    switch (TYPEOF(p)) {\n    case REALSXP :  return REAL(p)[idx];\n    case INTSXP : return INTEGER(p)[idx]==NA_INTEGER  \n\t? RF_NA : (double) INTEGER(p)[idx];\n    case LGLSXP : return LOGICAL(p)[idx]==NA_LOGICAL ? RF_NA \n\t: (double) LOGICAL(p)[idx];\n    default : {}\n    }\n  }\n\n ERR2(\"'%s' can not be transformed to double! (type=%d)\\n\", name, TYPEOF(p));  \n  return RF_NA;  // to avoid warning from compiler\n}\n\n\n\nvoid Real(SEXP el,  char *name, double *vec, int maxn) {\n  if (el == R_NilValue) {\n    ERR1(\"'%s' cannot be transformed to double.\\n\", name);\n  }\n  int n = length(el);\n  for (int j=0, i=0; i<maxn; i++) {\n    vec[i] = Real(el, name, j);\n    if (++j >= n) j=0;\n  }\n  return;\n}\n\n\nint Integer(SEXP p, char *name, int idx, bool nulltoNA) {\n  if (p != R_NilValue) {\n    assert(idx < length(p));\n    switch(TYPEOF(p)) {\n    case INTSXP : \n      return INTEGER(p)[idx]; \n    case REALSXP : \n      double value;\n      value = REAL(p)[idx];      \n      if (ISNAN(value)) {\n\treturn NA_INTEGER;\n      }\n      int intvalue;\n      intvalue = (int) value;\n      //      print(\"%f %d %e\\n \", value, intvalue, value-intvalue);\n      if (value == intvalue) return intvalue; \n      else {\n\tERR2(\"%s: integer value expected. Got %e.\", name, value);\n      }\n    case LGLSXP :\n      return  LOGICAL(p)[idx]==NA_LOGICAL ? NA_INTEGER : (int) LOGICAL(p)[idx];\n    default : {}\n    }\n  } else if (nulltoNA) return NA_INTEGER;\n  ERR2(\"%s: unmatched type of parameter [type=%d]\", name, TYPEOF(p));\n  return NA_INTEGER; // compiler warning vermeiden\n}\n\nint Integer(SEXP p, char *name, int idx) {\n  return Integer(p, name, idx, false);\n}\n\n\nvoid Integer(SEXP el, char *name, int *vec, int maxn) {\n  if (el == R_NilValue) {\n    ERR1(\"'%s' cannot be transformed to integer.\\n\",name);\n  }\n  int n = length(el);\n  for (int j=0, i=0; i<maxn; i++) {\n    vec[i] = Integer(el, name, j);\n    if (++j >= n) j=0;\n  }\n}\n\n\n\n\nvoid Integer2(SEXP el, char *name, int *vec) {\n  int n;\n  if (el == R_NilValue || (n = length(el))==0) {\n      ERR1(\"'%s' cannot be transformed to integer.\\n\",name);\n  }\n \n  vec[0] = Integer(el, name, 0);\n  if (vec[0] == NA_INTEGER || vec[0] < 1)\n    ERR1(\"first component of '%s' must be at least 1\", name);\n  if (n==1) vec[1] = vec[0];\n  else {\n    vec[1] = Integer(el, name, n-1);    \n    if ( vec[1] != NA_INTEGER && vec[1] < vec[0])\n      ERR1(\"'%s' must be increasing\", name);\n    if (n > 2) {\n      int v = vec[0] + 1;\n      for (int i = 1; i<n; i++, v++)\n\tif (Integer(el, name, i) != v)\n\t  ERR1(\"'%s' is not a sequence of numbers\",name); \n\n    }\n  }\n}\n\n\n\n\n\nbool Logical(SEXP p, char *name, int idx) {\n   if (p != R_NilValue)\n    assert(idx < length(p));\n    switch (TYPEOF(p)) {\n    case REALSXP: return ISNAN(REAL(p)[idx]) ? NA_LOGICAL : (bool) REAL(p)[idx];\n    case INTSXP :\n      return INTEGER(p)[idx]==NA_INTEGER ? NA_LOGICAL : (bool) INTEGER(p)[idx];\n    case LGLSXP : return LOGICAL(p)[idx];\n    default : {}\n    }\n  ERR1(\"'%s' cannot be transformed to logical.\\n\", name);  \n  return NA_LOGICAL;  // to avoid warning from compiler\n}\n\n\nchar Char(SEXP el, char *name) {\n  SEXPTYPE type;\n  if (el == R_NilValue) goto ErrorHandling;\n  type = TYPEOF(el);\n  if (type == CHARSXP) return CHAR(el)[0];\n  if (type == STRSXP) {\n    if (length(el)==1) {\n      if (STRLEN(CHAR(STRING_ELT(el,0))) == 1)\n\treturn (CHAR(STRING_ELT(el,0)))[0];\n      else if (STRLEN(CHAR(STRING_ELT(el,0))) == 0)\n\treturn '\\0';\n    }\n  }\n \n ErrorHandling:\n  ERR1(\"'%s' cannot be transformed to character.\\n\",  name);  \n  return 0; // to avoid warning from compiler\n}\n\n\nvoid String(SEXP el, char *name, char names[][MAXCHAR], int maxlen) {\n  int l = length(el);\n  SEXPTYPE type;  \n  if (el == R_NilValue) goto ErrorHandling;\n  if (l > maxlen)  {\n    ERR1(\"number of variable names exceeds %d. Take abbreviations?\", maxlen);\n  }\n  type = TYPEOF(el);\n  //  printf(\"type=%d %d %d %d\\n\", TYPEOF(el), INTSXP, REALSXP, LGLSXP);\n  if (type == CHARSXP) {\n    for (int i=0; i<l; i++) {\n      names[i][0] = CHAR(el)[i];\n      names[i][1] = '\\0';\n    }\n  } else if (type == STRSXP) {\n    for (int i=0; i<l; i++) {\n      //print(\"%d %d\\n\", i, l);\n      strcopyN(names[i], CHAR(STRING_ELT(el, i)), MAXCHAR);\n    }\n  } else goto ErrorHandling;\n  return;\n \n ErrorHandling:\n  ERR1(\"'%s' cannot be transformed to character.\\n\",  name);  \n}\n\n\ndouble NonNegInteger(SEXP el, char *name) {\n  int num;\n\n  num = INT;\n  if (num<0) {\n    num=0; \n    WARN1(\"'%s', which has been negative, is set 0.\\n\",name);\n  }\n  return num;\n}\n\ndouble NonNegReal(SEXP el, char *name) {\n  double num;\n  num = NUM;\n  if (num<0.0) {\n    num=0.0; \n    WARN1(\"%s, which has been negative, is set 0.\\n\",name);\n   }\n  return num;\n}\n\ndouble NonPosReal(SEXP el, char *name) {\n  double num;\n  num = NUM;\n  if (num>0.0) {\n    num=0.0; \n    WARN1(\"%s, which has been positive, is set 0.\\n\",name);\n  }\n  return num;\n}\n\ndouble PositiveInteger(SEXP el, char *name) {\n  int num;\n  num = INT;\n  if (num<=0) {\n    WARN2(\"'%s', which has been %s, is set 1.\\n\",\n\t  name, num==0L ? \"0\" : \"negative\");\n    num=1L;\n  }\n  return num;\n}\n\ndouble PositiveReal(SEXP el, char *name) {\n  double num;\n  num = NUM;\n  if (num<=0.0) {\n     WARN2(\"'%s', which has been %s, is set 1.\\n\",\n\t   name, num==0.0 ? \"0\" : \"negative\");\n     num=1.0; \n   }\n  return num;\n}\n\n\n\nSEXP ExtendedInteger(double x) {\n  return ScalarInteger(R_FINITE(x) ? x : NA_INTEGER);\n}\n\nSEXP ExtendedBooleanUsr(usr_bool x) {\n  return ScalarLogical((int) x);\n}\n\n\nint Match(char *name, name_type List, int n) {\n  // == -1 if no matching name is found\n  // == -2 if multiple matching names are found, without one matching exactly\n  unsigned int ln;\n  int Nr;\n  Nr=0;\n  ln=STRLEN(name);\n  //  print(\"Match %d %d %s %s %d\\n\", Nr, n, name, List[Nr], ln);\n\n  while ( Nr < n  && STRNCMP(name, List[Nr], ln)) {\n    Nr++;\n  }\n  if (Nr < n) { \n    if (ln==STRLEN(List[Nr])) // exactmatching -- take first -- changed 1/7/07\n      return Nr;\n    // a matching function is found. Are there other functions that match?\n    int j; \n    bool multiplematching=false;\n    j=Nr+1; // if two or more covariance functions have the same name \n    //            the last one is taken \n    while (j<n) {\n      while ( (j<n) && STRNCMP(name, List[j], ln)) {j++;}\n      if (j<n) {\n\tif (ln==STRLEN(List[j])) { // exactmatching -- take first \n\t  return j;\n\t}\n\telse {multiplematching=true;}\n      }\n      j++;\n    }\n    if (multiplematching) {return MULTIPLEMATCHING;}\n  } else return NOMATCHING;\n  return Nr;\n}\n\nint Match(char *name, const char * List[], int n) {\n  // printf(\"Matching\\n\");\n   // == -1 if no matching name is found\n  // == -2 if multiple matching names are found, without one matching exactly\n  unsigned int ln;\n  int Nr;\n  Nr=0;\n  ln=STRLEN(name);\n  //    print(\"Matchx %d %d %s %s %d\\n\", Nr, n, name, List[Nr], ln);\n\n  while ( Nr < n  && STRNCMP(name, List[Nr], ln)) {\n    //     print(\"       %d %d %s %s %d\\n\", Nr, n, name, List[Nr], ln);\n    //   printf(\"%s\\n\", List[Nr]);\n    Nr++;\n  }\n  if (Nr < n) { \n    if (ln==STRLEN(List[Nr])) {// exactmatching -- take first -- changed 1/7/07\n      //      print(\" found  X    %d %d %s %s %d\\n\", Nr, n, name, List[Nr], ln);\n      return Nr;\n    }\n    // a matching function is found. Are there other functions that match?\n    int j; \n    bool multiplematching=false;\n    j=Nr+1; // if two or more covariance functions have the same name \n    //            the last one is taken \n    while (j<n) {\n      while ( (j<n) && STRNCMP(name, List[j], ln)) {j++;}\n      if (j<n) {\n\tif (ln==STRLEN(List[j])) { // exactmatching -- take first \n\t  return j;\n\t}\n\telse {multiplematching=true;}\n      }\n      j++;\n    }\n    if (multiplematching) {return MULTIPLEMATCHING;}\n  } else return NOMATCHING;\n\n  //    print(\" found      %d %d %s %s %d\\n\", Nr, n, name, List[Nr], ln);\n \n  return Nr;\n}\n\n\n\nvoid GetName(SEXP el, char *name, const char * List[], int n,\n\t     int defaultvalue, int endvalue, int *ans, int maxlen_ans) {\n  char dummy[1000];\n  int \n    k = 0,\n    len_el = length(el);\n\n  if (TYPEOF(el) == NILSXP) goto ErrorHandling;\n  if (len_el > maxlen_ans) \n    ERR2(\"option '%s' is too long. Maximum length is %d.\", name, maxlen_ans);\n\n  if (TYPEOF(el) == STRSXP) {    \n    for (k=0; k<len_el; k++) {\n      ans[k] = Match((char*) CHAR(STRING_ELT(el, k)), List, n);\n      if (ans[k] < 0) {\n\tif (STRCMP((char*) CHAR(STRING_ELT(el, k)), \" \") == 0 ||\n\t    STRCMP((char*) CHAR(STRING_ELT(el, k)), \"\") == 0) {\n\t  goto ErrorHandling;\n\t}\n\tgoto ErrorHandling0;\n      }\n    }\n    for (; k<maxlen_ans; k++) ans[k] = endvalue;\n    return;\n  }\n\nErrorHandling0:\n  SPRINTF(dummy, \"'%s': unknown value '%s'. Possible values are:\", \n\t  name, CHAR(STRING_ELT(el, k)));\n  int i;\n  for (i=0; i<n-1; i++) {\n    char info[1000];\n    SPRINTF(info, \"%s '%s',\", dummy, List[i]);    \n    STRCPY(dummy, info);\n  }\n  ERR2(\"%s and '%s'.\", dummy, List[i]);  \n \n ErrorHandling:\n  if (defaultvalue >= 0) {\n    ans[0] = defaultvalue;\n    for (k=1; k<maxlen_ans; k++) ans[k] = endvalue;\n    return;\n  }\n  \n  ERR1(\"'%s': no value given.\", name);\n}\n\nint GetName(SEXP el, char *name, const char * List[], int n,\n\t    int defaultvalue) {\n  int i;\n  GetName(el, name, List, n, defaultvalue, defaultvalue, &i, 1);\n  return i;\n}\n\n\nint GetName(SEXP el, char *name, const char * List[], int n) {\n return GetName(el, name, List, n, -1);\n}\n\n\ndouble ownround(double x) { return TRUNC((x + SIGN(x) * 0.5)); }\n\n\ndouble lonmod(double x, double modulus) {  \n  double \n    halfmodulus = 0.5 * modulus,\n    y = x + modulus + halfmodulus;\n  return Mod(y, modulus) - halfmodulus;\n}\n\n/*\n\n\n\n\ndouble intpow(double x, int p) {\n  //int p0 = p;\n  // double x0 = x;\n\n  double res = 1.0;\n  if (p < 0) {\n    p = -p;\n    x = 1.0 / x;\n  } \n  while (p != 0) {\n    //    printf(\"  ... %e %d : %e\\n\" , x, p, res);\n  if (p % 2 == 1) res *= x;\n    x *= x;\n    p /= 2;\n  }\n  return res;\n}\n\n\n\nvoid distInt(int *X, int*N, int *Genes, double *dist) {\n    int i,j, k, di, diff, *x, *y, ve, ho, endfor,\n\tn = *N,\n\tnP1 = n + 1,\n\tgenes = *Genes;\n \n  x = y = X;\n  for (j=0, i=0;  j<n;  i += nP1, j++, y += genes) {\n    dist[i] = 0.0;\n    endfor = i + (n - j);\n    for (ve = i + 1, ho = i + n, x = y + genes; \n         ve < endfor; \n\t ve++, ho += n) {\n      for (di=0.0, k=0; k<genes; k++, x++) {\n\tdiff = *x - y[k];\n\tdi += diff * diff;\n      }\n      dist[ve] = dist[ho] = SQRT((double) di);\n    }\n  }\n}\n\n\nvoid vectordist(double *v, int *Dim, double *Dist, int *diag){\n  int d, dim, dr;\n  double *v1, *v2, *end;\n  bool notdiag = (*diag==0);\n  dim = Dim[0];\n  end = v + Dim[1] * dim; \n\n//  print(\"%d %d %f %f\\n\", dim , Dim[0], v, end);\n\n  for (dr=0, v1=v; v1<end; v1+=dim) { // loop is one to large??\n    v2 = v1;\n    if (notdiag) {\n       v2 += dim;\n    }\n    for (; v2<end; ) {\n      for (d=0; d<dim; v2++) {\n\tDist[dr++] = v1[d++] - *v2;\n      }\n    }\n  }\n} \n\n\nint addressbits(void VARIABLE_IS_NOT_USED *addr) {\n#ifndef RANDOMFIELDS_DEBUGGING  \n  return 0;\n#else\n  double x = (long int) addr,\n    cut = 1e9;\n  x = x - TRUNC(x / cut) * cut;\n  return (int) x;\n#endif\n\n}\n\n\n\n\n */\n\n",
    "created" : 1523602516374.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2797076776",
    "id" : "B7C13FD",
    "lastKnownWriteTime" : 1523279996,
    "last_content_update" : 1523279996,
    "path" : "C:/Users/tpook/Desktop/R-Stuff/HaploBlocker/src/kleinkram.cc",
    "project_path" : "src/kleinkram.cc",
    "properties" : {
    },
    "relative_order" : 80,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "cpp"
}