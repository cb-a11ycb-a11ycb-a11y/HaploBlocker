{
    "collab_server" : "",
    "contents" : "blocklist <- identify_blocks3(data, indi, nwindow, mindestanteil, trans_min=trans_min, subgroups=subgroups,\n                              consider_knoten=consider_knoten, consider_trans=consider_trans, min_per_subgroup=min_per_subgroup,\n                              intersect_func=intersect_func, consider_multi=consider_multi, multi_min=multi_min)\n\ncurrent_iteration <- max_iteration\nif(length(target_coverage)>0){\n  current_iteration <- 1\n  blocklist_start <- blocklist\n  block_min_counts <- numeric(max_iteration)\n  coverage_results <- numeric(max_iteration)\n  block_min_counts[1] <- block_min_count\n  blocklists <- list()\n  \n}\nstop_iteration <- FALSE\nwhile(current_iteration <= max_iteration && !stop_iteration){\n  \n  if(length(target_coverage)>0){\n    block_min_count <- block_min_counts[current_iteration]\n    blocklist <- blocklist_start\n  }\n  \n  \n  last.knoten2 <- last.knoten <- Inf\n  knoten <- length(blocklist)\n  iteration <- 1\n  print(\"Start_Blockmerging\")\n  helper <- blocklist_startend(blocklist)\n  helper_old <- NULL\n  while(length(helper_old)==0 || (nrow(helper_old)!=nrow(helper)) || prod(helper_old==helper)==0){\n    print(paste(\"Iteration\", iteration, \":\", knoten, \"Bloecke\"))\n    helper_old <- helper\n    blocklist <- block_merging(blocklist, blockinfo, dataset, dhm, indi, nwindow, window_sequence, off_lines, mindestaehnlichkeit=mindestaehnlichkeit,\n                               consider_all=consider_all, minimum.blocksize=minimum.blocksize, save_allblock=save_allblock, helper=helper,\n                               c_dhm=c_dhm, c_dhm_mode=c_dhm_mode, intersect_func=intersect_func,\n                               min_per_subgroup=min_per_subgroup)\n    \n    if(merge_closeblock==TRUE){\n      blocklist <- block_closeblock_merging(blocklist, blockinfo, indi, nwindow, max_diff_l, max_diff_i, intersect_func=intersect_func)\n    }\n    if(block_min_count>(0)){\n      if(block_min_count_steps>1){\n        blocklist <- blockinfo_biggest(blocklist, nwindow, indi, block_min_count=min(iteration-1, block_min_count_steps-1)/(block_min_count_steps-1)*block_min_count,\n                                       weighting_length=weighting_length, weighting_size=weighting_size,\n                                       recalculate_biggest=recalculate_biggest)\n      } else{\n        blocklist <- blockinfo_biggest(blocklist, nwindow, indi, block_min_count=block_min_count, weighting_length=weighting_length, weighting_size=weighting_size,\n                                       recalculate_biggest=recalculate_biggest)\n      }\n    }\n    helper <- blocklist_startend(blocklist)\n    knoten <- length(blocklist)\n    iteration <- iteration + 1\n  }\n  if(block_extending==TRUE){\n    knoten <- length(blocklist)\n    iteration <- 1\n    extentions_done <- 0\n    print(\"Start_Blockextending\")\n    while(iteration==1 || (nrow(helper_old)!=nrow(helper)) || prod(helper_old==helper)==0 || extentions_done > 0){\n      helper_old <- helper\n      print(paste(\"Iteration\", iteration, \":\", knoten, \"Bloecke; \", extentions_done, \"Blockerweiterungen\"))\n      blocklist_out <- extend_block(blocklist, indi, nwindow, max_extending_diff=max_extending_diff,\n                                    extending_ratio=extending_ratio, dataset=dataset, window_sequence=window_sequence)\n      blocklist <- blocklist_out[[1]]\n      extentions_done <- blocklist_out[[2]]\n      blocklist <- block_merging(blocklist, blockinfo, dataset, dhm, indi, nwindow, window_sequence, off_lines, mindestaehnlichkeit=mindestaehnlichkeit,\n                                 consider_all=consider_all, minimum.blocksize=minimum.blocksize, save_allblock=save_allblock, c_dhm=c_dhm,\n                                 c_dhm_mode=c_dhm_mode , intersect_func=intersect_func,\n                                 min_per_subgroup=min_per_subgroup)\n      \n      if(merge_closeblock==TRUE){\n        blocklist <- block_closeblock_merging(blocklist, blockinfo, indi, nwindow, max_diff_l, max_diff_i, intersect_func=intersect_func)\n      }\n      if(block_min_count_steps>1){\n        blocklist <- blockinfo_biggest(blocklist, nwindow, indi, block_min_count=min(iteration-1, block_min_count_steps-1)/(block_min_count_steps-1)*block_min_count,\n                                       weighting_length=weighting_length, weighting_size=weighting_size,\n                                       recalculate_biggest=recalculate_biggest)\n      } else{\n        blocklist <- blockinfo_biggest(blocklist, nwindow, indi, block_min_count=block_min_count,\n                                       weighting_length=weighting_length, weighting_size=weighting_size,\n                                       recalculate_biggest=recalculate_biggest)\n      }\n      \n      helper <- blocklist_startend(blocklist)\n      knoten <- length(blocklist)\n      iteration <- iteration + 1\n    }\n  }\n  \n  if(snp_extending==TRUE){\n    # Fuege anfang und ende gleiche SNPs im Randbereich hinzu/ab\n    blocklist <- extend_snp(blocklist, indi, nwindow, dhm, window_sequence, bp_map = bp_map,\n                            max_extending_diff_snp=max_extending_diff_snp, extending_ratio_snp=extending_ratio_snp)\n    \n  }\n  \n  if(off_knot_addition==TRUE){\n    blocklist <- add_offknot(blocklist=blocklist, dataset, indi, nwindow, window_sequence=window_sequence, bp_map=bp_map,\n                             off_knot_minimum_blocklength=off_knot_minimum_blocklength,\n                             off_knot_minimum_blocksize=off_knot_minimum_blocksize, raster=raster)\n    last.knoten2 <- last.knoten <- Inf\n    knoten <- length(blocklist)\n    iteration <- 1\n    print(\"Start_Blockmerging\")\n    while(last.knoten2!=knoten){\n      print(paste(\"Iteration\", iteration, \":\", knoten, \"Bloecke\"))\n      \n      blocklist <- block_merging(blocklist, blockinfo, dataset, dhm, indi, nwindow, window_sequence, off_lines, mindestaehnlichkeit=mindestaehnlichkeit,\n                                 consider_all=consider_all, minimum.blocksize=minimum.blocksize, save_allblock=save_allblock, c_dhm=c_dhm,\n                                 c_dhm_mode=c_dhm_mode, intersect_func=intersect_func,\n                                 min_per_subgroup=min_per_subgroup)\n      \n      if(merge_closeblock==TRUE){\n        blocklist <- block_closeblock_merging(blocklist, blockinfo, indi, nwindow, max_diff_l, max_diff_i, intersect_func=intersect_func)\n      }\n      if(block_min_count>(0)){\n        if(block_min_count_steps>1){\n          blocklist <- blockinfo_biggest(blocklist, nwindow, indi, block_min_count=min(iteration-1, block_min_count_steps-1)/(block_min_count_steps-1)*block_min_count,\n                                         weighting_length=weighting_length, weighting_size=weighting_size,\n                                         recalculate_biggest=recalculate_biggest)\n        } else{\n          blocklist <- blockinfo_biggest(blocklist, nwindow, indi, block_min_count=block_min_count,\n                                         weighting_length=weighting_length, weighting_size=weighting_size,\n                                         recalculate_biggest=recalculate_biggest)\n        }\n      }\n      \n      last.knoten2 <- last.knoten\n      last.knoten <- knoten\n      knoten <- length(blocklist)\n      iteration <- iteration + 1\n    }\n    \n    if(block_extending==TRUE){\n      last.knoten2 <- last.knoten <- Inf\n      knoten <- length(blocklist)\n      iteration <- 1\n      extentions_done <- 0\n      print(\"Start_Blockextending\")\n      while(last.knoten2!=knoten || extentions_done > 0){\n        print(paste(\"Iteration\", iteration, \":\", knoten, \"Bloecke; \", extentions_done, \"Blockerweiterungen\"))\n        blocklist_out <- extend_block(blocklist, indi, nwindow, max_extending_diff=max_extending_diff,\n                                      extending_ratio=extending_ratio, dataset=dataset, window_sequence=window_sequence)\n        blocklist <- blocklist_out[[1]]\n        extentions_done <- blocklist_out[[2]]\n        blocklist <- block_merging(blocklist, blockinfo, dataset, dhm, indi, nwindow, window_sequence, off_lines, mindestaehnlichkeit=mindestaehnlichkeit,\n                                   consider_all=consider_all, minimum.blocksize=minimum.blocksize, save_allblock=save_allblock, c_dhm=c_dhm,\n                                   c_dhm_mode=c_dhm_mode, intersect_func=intersect_func,\n                                   min_per_subgroup=min_per_subgroup)\n        \n        if(merge_closeblock==TRUE){\n          blocklist <- block_closeblock_merging(blocklist, blockinfo, indi, nwindow, max_diff_l, max_diff_i, intersect_func=intersect_func)\n        }\n        if(block_min_count_steps>1){\n          blocklist <- blockinfo_biggest(blocklist, nwindow, indi, block_min_count=min(iteration-1, block_min_count_steps-1)/(block_min_count_steps-1)*block_min_count,\n                                         weighting_length=weighting_length, weighting_size=weighting_size,\n                                         recalculate_biggest=recalculate_biggest)\n        } else{\n          blocklist <- blockinfo_biggest(blocklist, nwindow, indi, block_min_count=block_min_count, weighting_length=weighting_length, weighting_size=weighting_size,\n                                         recalculate_biggest=recalculate_biggest)\n        }\n        \n        last.knoten2 <- last.knoten\n        last.knoten <- knoten\n        knoten <- length(blocklist)\n        iteration <- iteration + 1\n      }\n    }\n    \n    if(snp_extending==TRUE){\n      # Fuege anfang und ende gleiche SNPs im Randbereich hinzu/ab\n      blocklist <- extend_snp(blocklist, indi, nwindow, dhm, window_sequence, bp_map = bp_map,\n                              max_extending_diff_snp=max_extending_diff_snp, extending_ratio_snp=extending_ratio_snp)\n      \n    }\n    \n  }\n  \n  if(length(target_coverage)>0){\n    \n    blocklists[[current_iteration]] <- blocklist\n    t <- coverage_test(blocklist, indi, type=\"snp\")\n    coverage_results[current_iteration] <- mean(t)\n    prev_cov <- coverage_results[coverage_results>0]\n    prev_block <- block_min_counts[block_min_counts>0]\n    if(min(prev_cov) > target_coverage){\n      block_min_counts[current_iteration + 1] <- max(max(prev_block)*2, max(prev_block)+min_step_size)\n    } else if(max(prev_cov) < target_coverage){\n      block_min_counts[current_iteration + 1] <- max(min(ceiling(min(prev_block)/2), min(prev_block) - min_step_size),1)\n    } else{\n      if(current_iteration==1){\n        stop_iteration <- TRUE\n      } else{\n        pos <- ((prev_cov-target_coverage)>0) * (1:length(prev_cov))\n        neg <- ((prev_cov-target_coverage)<0) * (1:length(prev_cov))\n        ordering <- sort(abs(prev_cov-target_coverage), index.return=TRUE)$ix\n        neg <- base::intersect(ordering, neg)\n        pos <- base::intersect(ordering, pos)\n        block_min_counts[current_iteration + 1] <- ceiling(mean(prev_block[c(pos[1], neg[1])]))\n      }\n      \n    }\n    print(paste(\"Finish Target_Coverage Iteration\", current_iteration))\n    print(paste(\"Used block_min_count:\", block_min_counts[current_iteration]))\n    print(paste(\"Achieved Coverage:\", coverage_results[current_iteration]))\n    if(current_iteration<max_iteration){\n      print(paste(\"Start next iteration using block_min_count:\", block_min_counts[current_iteration+1]))\n    }\n    \n    if(abs(coverage_results[current_iteration] - target_coverage)<target_stop){\n      stop_iteration <- TRUE\n    }\n    \n    \n    \n    \n  }\n  current_iteration <- current_iteration + 1\n  \n}\n\nif(length(target_coverage)>0){\n  print(paste(\"Final Iteration using \",  block_min_counts[current_iteration-1]))\n  print(paste(\"Achieved Coverage:\", coverage_results[current_iteration-1]))\n  take <- which.max(-abs(coverage_results-target_coverage))[1]\n  blocklist <- blocklists[[take]]\n}\n\n\nif(major_snp_calculation==TRUE){\n  blocklist <- major_snp_calculation(blocklist, dhm, recoding=recoding)\n}\n\n",
    "created" : 1521125609219.000,
    "dirty" : true,
    "encoding" : "",
    "folds" : "",
    "hash" : "2831994424",
    "id" : "5758EA2C",
    "lastKnownWriteTime" : 7017771641159557747,
    "last_content_update" : 1521125612323,
    "path" : null,
    "project_path" : null,
    "properties" : {
        "tempName" : "Untitled57"
    },
    "relative_order" : 59,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}