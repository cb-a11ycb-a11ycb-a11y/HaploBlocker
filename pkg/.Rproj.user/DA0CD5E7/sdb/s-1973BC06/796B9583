{
    "collab_server" : "",
    "contents" : "#' Merge blocks\n#'\n#' Function to merge/remove/modify blocks\n#' @param blocklist block-dataset\n#' @param indi number of haplotypes in the dataset\n#' @param nwindow number of windows in the dataset\n#' @param blockinfo List with all relevant information to each window seperatly\n#' @param dhm haploid SNP-dataset\n#' @param window_sequence_list sequence of predefined windows (default: NULL ;per row: start$snp, end$snp, length, length - merging_error, start$bp, end$bp)\n#' @param dataset dataset which variant nr. for each window\n#' @param off_lines minimum number of haplotypes to looose in the creation of a bigger block (default: 5)\n#' @param min_similarity minimum rate of the same SNPs to be added to the block (default: 0.99)\n#' @param consider_all If TRUE always haplotypes which are not in the node to be in a generated block\n#' @param save_allblock If TRUE keep all haplotypes with all windows according to a block (even under min_similarity)\n#' @param node_min minimum number of haplotypes per block (default: 5)\n#' @param subgroups possible subgroups to consider in the block identification process (default: NULL - list(1:indi))\n#' @param min_per_subgroup minimum number of haplotypes per block per subgroup (default: 0)\n#' @param anteil_filter Use only relevant Sequences for filter which haplotypes to check in min_similarity\n#' @param intersect_func Used intersect-function (internally relevant for computation time)\n#' @param helper Interal information used as a fast abort criterion\n#' @param c_dhm Bit-wise coded SNP-dataset\n#' @param c_dhm_mode If TRUE use high speed calculation with C in block_merging (default: TRUE)\n#' @export\n\n\nblock_merging <- function(blocklist, blockinfo, dataset, dhm, indi, nwindow, window_sequence_list,  off_lines=5, min_similarity=0.99, consider_all=TRUE,\n                          save_allblock=TRUE, node_min=0, subgroups=NULL, min_per_subgroup= 0, anteil_filter=TRUE, helper=NULL,\n                          c_dhm=NULL, c_dhm_mode=TRUE, intersect_func=intersect){\n  if(length(helper)==0){\n    helper <- rowSums(blocklist_startend(blocklist, type=\"snp\"))\n  } else{\n    helper <- rowSums(helper)\n  }\n  n <- length(helper)\n\n  if(length(blocklist)>1){\n    for(index in length(blocklist):1){\n      if(index==1){\n        possible_same <- numeric(0)\n      } else{\n        possible_same <- (1:(index-1))[(helper[1:(index-1)] == helper[index]) * (1:(index-1)) ]\n      }\n\n      no.merge <- 1\n\n      cluster <- blocklist[[index]][[12]]\n      haplotyp <- blocklist[[index]][[4]]\n\n      if(length(blocklist[[index]])>=7 && length(blocklist[[index]][[7]])>0 && length(blocklist[[index]][[7]]$snp)==(blocklist[[index]][[3]]$snp-blocklist[[index]][[2]]$snp+1 )){\n        major <- blocklist[[index]][[7]]$snp\n      } else{\n        major <- numeric(blocklist[[index]][[3]]$snp - blocklist[[index]][[2]]$snp+1)\n        for(index2 in blocklist[[index]][[2]]$window:blocklist[[index]][[3]]$window){\n          major[window_sequence_list[[cluster]][index2,1]:window_sequence_list[[cluster]][index2,2] - window_sequence_list[[cluster]][blocklist[[index]][[2]]$window,1] +1] <- blockinfo[[cluster]][[index2]][[6]][[haplotyp[index2-blocklist[[index]][[2]]$window+1]]]\n        }\n        blocklist[[index]][[7]]$snp <- major\n      }\n\n      for(check in possible_same){\n        if(no.merge==1 && blocklist[[check]][[2]]$snp == blocklist[[index]][[2]]$snp){\n\n          cluster2 <- blocklist[[check]][[12]]\n          haplotyp2 <- blocklist[[check]][[4]]\n          if(length(blocklist[[check]])>=7 && length(blocklist[[check]][[7]])>0 && length(blocklist[[check]][[7]]$snp)==(blocklist[[check]][[3]]$snp-blocklist[[check]][[2]]$snp+1 ) ){\n            major2 <- blocklist[[check]][[7]]$snp\n          } else{\n            major2 <- numeric(blocklist[[check]][[3]]$snp - blocklist[[check]][[2]]$snp+1)\n            for(index2 in blocklist[[check]][[2]]$window:blocklist[[check]][[3]]$window){\n              major2[window_sequence_list[[cluster2]][index2,1]:window_sequence_list[[cluster2]][index2,2] - window_sequence_list[[cluster2]][blocklist[[check]][[2]]$window,1] +1] <- blockinfo[[cluster2]][[index2]][[6]][[haplotyp2[index2-blocklist[[check]][[2]]$window+1]]]\n            }\n            blocklist[[check]][[7]]$snp <- major2\n          }\n\n\n          merge <- prod(blocklist[[index]][[7]]$snp == blocklist[[check]][[7]]$snp)\n          if(blocklist[[check]][[1]][1]==\"Off-Window-Variant\"){\n            merge <- 0\n          }\n          if(blocklist[[check]][[1]][1]==\"Off-Window-Variant\" && blocklist[[check]][[1]][1]==\"Off-Window-Variant\" ){\n            if(blocklist[[check]][[2]]$window == blocklist[[index]][[2]]$window && prod( blocklist[[check]][[4]]==blocklist[[index]][[4]])){\n              merge <- 1\n            }\n          }\n          if(merge==1 ){\n            blocklist[[check]][[6]] <- sort(unique(blocklist[[check]][[6]], blocklist[[index]][[6]]))\n            blocklist[[check]][[5]] <- length(blocklist[[check]][[6]])\n            blocklist[[index]] <- NULL\n            no.merge <-0\n          }\n        }\n      }\n    }\n  }\n\n\n  # Loesche Enthaltende\n  be <- blocklist_startend(blocklist, type=\"snp\")\n\n  for(index in nrow(be):1){\n    possible <- (1:nrow(be))[(be[index,1]>= be[,1]) * (be[index,2]<= be[,2]) *(1:nrow(be)) * (1:nrow(be)!=index)]\n    ueberdeckung <- NULL\n    for(check in possible){\n      control <- prod(blocklist[[check]][[7]]$snp[(be[index,1]-be[check,1]+1):(be[index,2]-be[check,1]+1)] == blocklist[[index]][[7]]$snp)\n      if(control==1){\n        ueberdeckung <- unique(c(ueberdeckung, blocklist[[check]][[6]]))\n      }\n    }\n    # Sortierung nicht notwendig aber einzige Stelle mit Nicht-Sortierten Intersect-Elementen\n    if(length(ueberdeckung)>0){\n      ueberdeckung <- sort(ueberdeckung)\n    }\n\n    ueberdeckung <- intersect_func(ueberdeckung, blocklist[[index]][[6]])\n    if(length(ueberdeckung)>(blocklist[[index]][[5]]-off_lines)){\n      blocklist[[index]] <- \"NULL\"\n      be[index,1] <- be[index,2] <- 0\n    }\n  }\n  for(index in nrow(be):1){\n    if(length(blocklist[[index]])==1){\n      blocklist[[index]] <- NULL\n    }\n  }\n\n  # Kontrolle Enthalten\n\n  for(index in 1:length(blocklist)){\n    if(length(blocklist[[index]][[10]])==0 || blocklist[[index]][[10]] != (blocklist[[index]][[3]]$snp - blocklist[[index]][[2]]$snp +1)){\n\n      haplotyp <- blocklist[[index]][[4]]\n      major <- blocklist[[index]][[7]]$snp\n      anteil <- numeric(indi)\n      blockanteil <- numeric(indi)\n      cluster <- blocklist[[index]][[12]]\n\n      # Blockanteil-Rechnung\n      if(consider_all==TRUE){\n        blockanteil <- colSums(dataset[[cluster]][blocklist[[index]][[2]]$window:blocklist[[index]][[3]]$window,, drop=FALSE]==blocklist[[index]][[4]])\n\n      } else{\n        blockanteil[blocklist[[index]][[6]]] <- colSums(dataset[[cluster]][blocklist[[index]][[2]]$window:blocklist[[index]][[3]]$window,blocklist[[index]][[6]], drop=FALSE]==blocklist[[index]][[4]])\n      }\n      # Anteil - Rechnung\n      to_consider <- 1:indi\n      if(anteil_filter==TRUE){\n        to_consider <- to_consider[!(blockanteil==length(haplotyp))]\n        if(length(blocklist[[index]])>=9 && length(blocklist[[index]][[9]])>0){\n          laenge <- blocklist[[index]][[3]]$snp - blocklist[[index]][[2]]$snp + 1\n          max_anteil <- blocklist[[index]][[9]][to_consider,1] + laenge - blocklist[[index]][[9]][to_consider,2]\n          to_consider <- to_consider[max_anteil > (laenge * min_similarity)]\n        }\n\n      }\n      if(!consider_all){\n        to_consider <- intersect_func(to_consider, blocklist[[index]][[6]])\n      }\n      if(length(to_consider)>0){\n\n        if(c_dhm_mode==TRUE){\n          anteil[to_consider] <- colSumsEqualSNPs(c_dhm, blocklist[[index]][[2]]$snp, major, to_consider)\n        } else{\n          anteil[to_consider] <-colSums(dhm[blocklist[[index]][[2]]$snp:blocklist[[index]][[3]]$snp,to_consider, drop=FALSE]==major)\n\n        }\n      }\n\n      keep <- which((anteil > ((blocklist[[index]][[3]]$snp - blocklist[[index]][[2]]$snp +1 )*min_similarity)) + save_allblock* (blockanteil == length(haplotyp))>0)\n\n\n      if(anteil_filter==TRUE){\n        if(length(blocklist[[index]])>=9 && length(blocklist[[index]][[9]])>0){\n          blocklist[[index]][[9]][to_consider,] <- cbind(anteil[to_consider], blocklist[[index]][[3]]$snp - blocklist[[index]][[2]]$snp + 1)\n          blocklist[[index]][[9]][blockanteil==length(haplotyp),] <- blocklist[[index]][[3]]$snp - blocklist[[index]][[2]]$snp + 1\n        } else{\n          blocklist[[index]][[9]] <- cbind(anteil, blocklist[[index]][[3]]$snp - blocklist[[index]][[2]]$snp +1)\n          blocklist[[index]][[9]][blockanteil==length(haplotyp),] <- blocklist[[index]][[3]]$snp - blocklist[[index]][[2]]$snp + 1\n        }\n\n      }\n      blocklist[[index]][[10]] <- blocklist[[index]][[3]]$snp - blocklist[[index]][[2]]$snp + 1\n\n      previous <- blocklist[[index]][[6]]\n\n\n      ## Erlaube Statt gleichheit mit Major gleichheit mit einer beliebigen Variante\n      #ant <- anteil[blocklist[[index]][[6]]] / (window_size * length(haplotyp))\n      #test <- dhm[((blocklist[[index]][[2]]-1)*(window_size)+1):(blocklist[[index]][[3]]*(window_size)),blocklist[[index]][[6]]]==major\n      #snp <- dhm[((blocklist[[index]][[2]]-1)*(window_size)+1):(blocklist[[index]][[3]]*(window_size)),blocklist[[index]][[6]]]\n      #\n      #plot(ksmooth(1:nrow(test), rowSums(test), bandwidth=10))\n      ##\n\n      blocklist[[index]][[6]] <- keep\n\n      blocklist[[index]][[5]] <- length(blocklist[[index]][[6]])\n    }\n  }\n  if(min_per_subgroup>0){\n    for(index in length(blocklist):1){\n      remover <- 0\n      for(group in subgroups){\n        if(length(intersect_func(blocklist[[index]][[6]], group))< min_per_subgroup){\n          remover <- 1\n        }\n      }\n      if(remover==1){\n        blocklist[[index]] <- NULL\n      }\n    }\n  }\n  blocklist <- blocklist_reorder(blocklist, node_min)\n\n\n\n  return(blocklist)\n}\n",
    "created" : 1523351982351.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "140326085",
    "id" : "796B9583",
    "lastKnownWriteTime" : 1524235552,
    "last_content_update" : 1524235552820,
    "path" : "C:/Users/tpook/Desktop/R-Stuff/HaploBlocker/R/block_merging.R",
    "project_path" : "R/block_merging.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "relative_order" : 65,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}