{
    "collab_server" : "",
    "contents" : "#' Mainfunction to calculate haplotype blocks\n#'\n#' Function to generate haplotype blocks from haploid data\n#' @param dhm haploid SNP-dataset\n#' @param window_size size of each window in the algorithm (default: 20)\n#' @param merging_error number of allowed errors per block (default: 1)\n#' @param window_sequence sequence of predefined windows (default: NULL ;per row: start$snp, end$snp, length, length - merging_error, start$bp, end$bp)\n#' @param bp_map vector of positions for each SNP in bp (default: NULL - all 0)\n#' @param window_anchor_gens matrix to constructed window_sequence base on start/end points in bp (e.g. gen regions, per row: start, gen)\n#' @param at_least_one If TRUE no allowed merging errors in windows of size 1\n#' @param blockinfo_mode Structure of the groups in step I (default: 0 - Common haplos as major variants, 1- minimum number of groups)\n#' @param actual_snp_weight Set weight for difference between two alleles in a SNP (more than 1 possible base pair)\n#' @param na_snp_weight Set weight for difference between NA and allele in a SNP (more than 1 possible base pair)\n#' @param na_seq_weight Set weight for difference between NA and allele a loci with 1 possible base pair\n#' @export\n\n\nblockinfo_calculation_na <- function(dhm, window_sequence=NULL, window_size=32, merging_error=3, bp_map=NULL,\n                                  window_anchor_gens=NULL, at_least_one=TRUE, blockinfo_mode=0, actual_snp_weight = 5,\n                                  na_snp_weight=2, na_seq_weight=0){\n\n  if(length(window_anchor_gens)>0 && length(window_sequence)==0 && length(bp_map)>0){\n    window_sequence <- matrix(0, ncol=2, nrow=nrow(window_anchor_gens)*2+1)\n    start <- 1\n    for(index in 1:nrow(window_anchor_gens)){\n      end <- sum(bp_map<window_anchor_gens[index,1])\n      window_sequence[index*2-1,] <- c(start, end)\n      end2 <- sum(bp_map<=window_anchor_gens[index,2])\n      window_sequence[index*2,] <- c(end+1, end2)\n      start <- end2+1\n    }\n    window_sequence[index*2+1,] <- c(start, length(bp_map))\n    removes <-(window_sequence[,1]>window_sequence[,2])*(1:nrow(window_sequence))\n    window_sequence <- window_sequence[-removes,]\n  }\n\n  if(length(window_sequence)==0){\n    window_sequence <- cbind(0:(nrow(dhm)/window_size-1)*window_size+1, 1:(nrow(dhm)/window_size)*window_size)\n  }\n  if(ncol(window_sequence)==2){\n    window_sequence <- cbind(window_sequence, window_sequence[,2]-window_sequence[,1]+1, window_sequence[,2]-window_sequence[,1]-merging_error+1)\n  }\n  if(ncol(window_sequence)==3){\n    window_sequence <- cbind(window_sequence[,1:2], window_sequence[,2]-window_sequence[,1]+1, window_sequence[,2]-window_sequence[,1]+1-window_sequence[,3])\n  }\n  if(at_least_one== TRUE && sum(window_sequence[,4]==0)>0){\n    window_sequence[window_sequence[,4]==0, 4] <- 1\n  }\n\n  cat(\"Start_blockinfo_calculation\\n\")\n  blockinfo <- list()\n  indi <- ncol(dhm)\n  ite <- nrow(window_sequence)\n\n  last.block <- rep(1, indi)\n  nblocks.old <- 1\n  old.ac <- 1\n  for(index in 1:ite){\n    blockinfo[[index]] <- list()\n    if(ite<=25 || index%%round(ite/25.1)==0){\n      cat(\".\")\n    }\n    activ <- dhm[window_sequence[index,1]:window_sequence[index,2],]\n    if(is.matrix(activ)==FALSE){\n      activ <- t(as.matrix(activ))\n    }\n    snp_weight <- rep(1, window_sequence[index,3])\n    na_weight <- rep(na_seq_weight, window_sequence[index,3])\n    if(TRUE){\n      for(checkor in 1:window_sequence[index,3]){\n        possible_snp <- unique(c(9, activ[checkor,]))\n        if(length(possible_snp)>2){\n          snp_weight[checkor] <- actual_snp_weight\n          na_weight[checkor] <- actual_snp_weight - na_snp_weight\n          window_sequence[index,4] <- window_sequence[index,4] +actual_snp_weight -1\n        }\n      }\n    }\n\n    vers <- t(unique(activ, MARGIN=2))\n    nblocks <- nrow(vers)\n\n    similarity <- matrix(0, ncol=nblocks, nrow=nblocks)\n    for(col in 1:nblocks){\n      for(row in 1:col){\n\n        similarity[row,col] <- sum((vers[col,]==vers[row,])*snp_weight) + sum( ((vers[col,]==9)*(vers[row,]!=9) + (vers[col,]==9)*(vers[row,]!=9)) * na_weight)\n        similarity[col,row] <- similarity[row,col]\n      }\n    }\n\n    if(blockinfo_mode==1){\n      # Similarity-Merging\n      skip <- rep(FALSE, nblocks)\n      nr.coding <- 1:nblocks\n      for(index3 in 1:nblocks){\n        if(skip[index3]==FALSE){\n          options <- similarity[index3,]\n          merges <- unique(c(0,(options>=(window_sequence[index,4])) * (1:nblocks)))[-1]\n          if(length(merges)>1){\n            options <- similarity[merges,]\n            merges <- unique(c(0,t(options>=(window_sequence[index,4])) * (1:nblocks)))[-1]\n          }\n          skip[merges] <- TRUE\n          nr.coding[merges] <- index3\n        }\n      }\n\n\n      options <- numeric(nrow(vers))\n      for(index2 in 1:length(options)){\n        options[index2] <- paste0(vers[index2,], collapse = \"\")\n      }\n      func1 <- function(x){\n        x0 <- paste(x, collapse=\"\")\n        which(options==x0)\n      }\n      current.block <- apply(activ, MARGIN=2, func1)\n\n\n      for(switch in 1:nblocks){\n        if(nr.coding[switch]!=switch){\n          current.block[current.block==switch] <- nr.coding[switch]\n        }\n      }\n      hblocks <- numeric(nblocks)\n      for(count in 1:nblocks){\n        hblocks[count] <- sum(current.block==count)\n      }\n    } else{\n\n\n      options <- numeric(nrow(vers))\n      for(index2 in 1:length(options)){\n        options[index2] <- paste0(vers[index2,], collapse = \"\")\n      }\n      func1 <- function(x){\n        x0 <- paste(x, collapse=\"\")\n        which(options==x0)\n      }\n      current.block <- apply(activ, MARGIN=2, func1)\n\n\n      hblocks <- numeric(nblocks)\n      for(count in 1:nblocks){\n        hblocks[count] <- sum(current.block==count)\n      }\n\n      ordering <- sort(hblocks, decreasing=TRUE, index.return=TRUE)$ix\n\n      current <- 1\n      skip <- rep(FALSE, nblocks)\n      nr.coding <- 1:nblocks\n      for(index3 in ordering){\n        new_p <- ordering[which(similarity[ordering[1:current], index3]>=window_sequence[index,4])[1]]\n        if(new_p!=index3){\n          skip[index3] <- TRUE\n          nr.coding[index3] <- new_p\n          current.block[current.block==index3] <- nr.coding[new_p]\n          similarity[index3,] <- similarity[new_p,]\n          similarity[,index3] <- similarity[,new_p]\n          current.block[current.block==index3] <- new_p\n        }\n        current <- current+1\n\n\n      }\n\n      hblocks <- numeric(nblocks)\n      for(count in 1:nblocks){\n        hblocks[count] <- sum(current.block==count)\n      }\n    }\n\n\n    transition <- matrix(0, ncol=nblocks.old, nrow=nblocks)\n    for(new in 1:nblocks){\n      for(old in 1:nblocks.old){\n        transition[new,old] <- sum((current.block==new)*(last.block==old))\n      }\n    }\n    ac <- unique(nr.coding)\n    blockinfo[[index]][[1]] <- hblocks[ac]\n    blockinfo[[index]][[2]] <- rbind(similarity[ac,ac],NULL)\n    blockinfo[[index]][[3]] <- transition[ac,old.ac]\n    if(is.matrix(transition[ac,old.ac])==FALSE){\n      if(length(old.ac)==1) {\n        blockinfo[[index]][[3]] <- cbind(transition[ac,old.ac], NULL)\n      } else{\n        blockinfo[[index]][[3]] <- matrix(transition[ac,old.ac], nrow=1)\n      }\n    }\n    blockinfo[[index]][[4]] <- list()\n    for(listn in 1:length(ac)){\n      blockinfo[[index]][[4]][[listn]] <- rbind(vers[nr.coding==ac[listn],],NULL)\n    }\n    blockinfo[[index]][[5]] <- list()\n    for(listn in 1:length(ac)){\n      blockinfo[[index]][[5]][[listn]] <- which(current.block==ac[listn])\n    }\n\n    last.block <- current.block\n    nblocks.old <- nblocks\n    old.ac <- ac\n\n\n    pos <- numeric(length(vers))\n  }\n\n  for(index in 1:length(blockinfo)){\n    blockinfo[[index]][[6]] <- list()\n    for(index2 in 1:length(blockinfo[[index]][[4]])){\n      count <- numeric(nrow(blockinfo[[index]][[4]][[index2]]))\n      if(length(count)>1){\n        for(index3 in 1:length(count)){\n          count[index3] <- sum(dhm[window_sequence[index,1]:window_sequence[index,2], blockinfo[[index]][[5]][[index2]]] == blockinfo[[index]][[4]][[index2]][index3,])\n        }\n      }else{\n        count <- 1\n      }\n      blockinfo[[index]][[6]][[index2]] <- blockinfo[[index]][[4]][[index2]][which.max(count),]\n\n    }\n  }\n  if(length(bp_map)==0){\n    bp_map <- rep(0, max(window_sequence[,2]))\n  }\n  for(index in 1:length(blockinfo)){\n    blockinfo[[index]][[7]] <- c(bp_map[window_sequence[index,1]], bp_map[window_sequence[index,2]])\n  }\n  if(length(bp_map)>0 && ncol(window_sequence)==4){\n    window_sequence <- cbind(window_sequence, bp_map[window_sequence[,1]], bp_map[window_sequence[,2]])\n  }\n\n  return(list(blockinfo, window_sequence))\n}\n\n\n",
    "created" : 1524223749239.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1584492835",
    "id" : "3148A785",
    "lastKnownWriteTime" : 1524732735,
    "last_content_update" : 1524732735409,
    "path" : "C:/Users/tpook/Desktop/R-Stuff/HaploBlocker/R/blockinfo_calculation_na.R",
    "project_path" : "R/blockinfo_calculation_na.R",
    "properties" : {
    },
    "relative_order" : 100,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}