{
    "collab_server" : "",
    "contents" : "library(HaploBlocker)\nlibrary(CHaploBlocker)\n\nblocklist <- block_calculation(ex_maze, block_min_count = 500)\n\ntype=\"snp\"\noriantation=\"snp\"\ninclude=TRUE\nindi=501\nmin_to_plot = 5\nintensity=0.5\nadd_sort=TRUE\nmax_step=500\nsnp_ori=NULL\nexport_order=FALSE\nimport_order=FALSE\n\noriantation_f <- oriantation\n  se <- blocklist_startend(blocklist, type=type)\n  order <- NULL\n  \n  if(length(oriantation_f)==0){\n    order <- 1:indi\n  } else if(oriantation_f[1]==\"front\"){\n    oriantation <- 1:8\n  } else if(oriantation_f[1]==\"mid\"){\n    oriantation <- 1:8 + ceiling(nrow(se)/2-3)\n  } else if(oriantation_f[1]==\"back\"){\n    oriantation <- 1:8 + nrow(se) -8\n  } else if(oriantation_f[1]==\"snp\"){\n    if(length(snp_ori)==0){\n      snp_ori <- mean(c(max(se), min(se)))\n    }\n    oriantation <- which(((se[,1]<= snp_ori)+ (se[,2]>= snp_ori))==2)\n  } else{\n    order <- oriantation_f\n  }\n  \n  if(length(oriantation)>0 && import_order==FALSE){\n    sorted <- oriantation[1]\n    oriantation <- oriantation[-1]\n    while(length(oriantation)>0){\n      overlap <- numeric(length(oriantation))\n      actives <- blocklist[[sorted[length(sorted)]]][[6]]\n      i1 <- 1\n      for(index in oriantation){\n        nextone <- blocklist[[index]][[6]]\n        overlap[i1] <- length(intersect(nextone,actives))/ length(nextone)\n        i1 <- i1 + 1\n      }\n      sorted <- c(sorted, oriantation[which.max(overlap)[1]])\n      oriantation <- oriantation[-which.max(overlap)[1]]\n    }\n    oriantation <- sorted\n    \n  }\n  if(length(order)==0){\n    if(include==TRUE){\n      oriantation <- c(oriantation, 0)\n    }\n    for(index in oriantation){\n      print(index)\n      pl <- length(order)\n      if(index==0){\n        order <- unique(c(order,1:indi))\n        index <- ceiling(median(oriantation[-length(oriantation)]))\n      } else{\n        order <- unique(c(order,blocklist[[index]][[6]]))\n      }\n      \n      if(add_sort==TRUE && length(order)>pl){\n        if(pl>0){\n          added <- order[-(1:pl)]\n        } else{\n          added <- order\n        }\n        groups <- list()\n        groups[[1]] <- added\n        for(step in 1:max_step){\n          \n          if(length(groups)<length(added)){\n            if((index-step) >0 && length(intersect(blocklist[[index-step]][[6]], added))>0){\n              new_groups <- list()\n              for(group in 1:length(groups)){\n                same <- base::intersect(groups[[group]], blocklist[[index-step]][[6]])\n                rest <- base::intersect(groups[[group]], (1:indi)[-blocklist[[index-step]][[6]]])\n                if(length(same)>0){\n                  new_groups[[length(new_groups)+1]] <- same\n                }\n                if(length(rest)>0){\n                  new_groups[[length(new_groups)+1]] <- rest\n                }\n                \n              }\n              groups <- new_groups\n            }\n            if((index+step) <=length(blocklist) && length(intersect(blocklist[[index+step]][[6]], added))>0){\n              new_groups <- list()\n              for(group in 1:length(groups)){\n                same <- base::intersect(groups[[group]], blocklist[[index+step]][[6]])\n                rest <- base::intersect(groups[[group]], (1:indi)[-blocklist[[index+step]][[6]]])\n                if(length(same)>0){\n                  new_groups[[length(new_groups)+1]] <- same\n                }\n                if(length(rest)>0){\n                  new_groups[[length(new_groups)+1]] <- rest\n                }\n                \n                \n              }\n              groups <- new_groups\n            }\n          }\n          \n        }\n        if(pl>0){\n          order <- c(order[(1:pl)],unlist(groups))\n        } else{\n          order <- c(unlist(groups))\n        }\n        \n\n      }\n    }\n    \n    \n  }\n  X11(width=16, height = 7.5)\n  par(mfrow=c(1,1))\n  par(mar=rep(5,4))\n  plot(0,-1000,ylim=c(0,length(order)), xlim=c(1,max(se)), ylab=\"\", xlab=\"SNP\", cex.axis=2, cex.lab=2, axes=TRUE)\n  title(ylab=\"haplotype\",mgp=c(3,1,0), cex.lab=2)\n  activ_colors <- numeric(length(blocklist))\n  for(index in 1:length(blocklist)){\n    overlap <- duplicated(c(blocklist[[index]][[6]], order))[-(1:blocklist[[index]][[5]])]\n    if(sum(overlap) >= min_to_plot){\n      print(index)\n      taken <- base::intersect(which(se[,1]<=se[index,2]), which(se[,2]>=se[index,1]))\n      block_color <- sort(unique(c(0,activ_colors[taken])))\n      activ_colors[index] <- min(length(block_color),which(block_color!=(1:length(block_color)-1))-1)\n      for(index2 in which(overlap)){\n        polygon(c(se[index,1], se[index,2], se[index,2], se[index,1]), index2-c(1,1,0,0),\n                col=adjustcolor(activ_colors[index],alpha.f=intensity), lty=0)\n      }\n    }\n  }\n  savePlot(\"C:/Users/tpook/Desktop/PosterHaploBlocker/HaploBlocker_sort.png\", type=\"png\")\n\n",
    "created" : 1514989031652.000,
    "dirty" : true,
    "encoding" : "",
    "folds" : "",
    "hash" : "680938932",
    "id" : "19080FC",
    "lastKnownWriteTime" : 0,
    "last_content_update" : 1520525093481,
    "path" : null,
    "project_path" : null,
    "properties" : {
        "tempName" : "Untitled42"
    },
    "relative_order" : 22,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}