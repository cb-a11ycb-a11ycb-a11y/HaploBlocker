{
    "collab_server" : "",
    "contents" : "#' Mainfunction to calculate haplotype blocks\n#'\n#' Function to generate haplotype blocks from haploid data\n#' @param dhm haploid SNP-dataset\n#' @param window_size size of each window in the algorithm (default: 20)\n#' @param merging_error number of allowed errors per block (default: 1)\n#' @param window_sequence sequence of predefined windows (default: NULL ;per row: start$snp, end$snp, length, length - merging_error, start$bp, end$bp)\n#' @param bp_map vector of positions for each SNP in bp (default: NULL - all 0)\n#' @param window_anchor_gens matrix to constructed window_sequence base on start/end points in bp (e.g. gen regions, per row: start, end)\n#' @param at_least_one If TRUE no allowed merging errors in windows of size 1\n#' @param node_min minimum number of haplotypes per block (default: 5)\n#' @param gap remove haplotypes in nodes adjacent to nodes with less than min_node haplotypes in it (default: 10 windows)\n#' @param min_share minimum percentage of transition to the same block for extension (default: 0.95, step III)\n#' @param off_lines minimum number of haplotypes to looose in the creation of a bigger block (default: 5)\n#' @param min_similarity minimum rate of the same SNPs to be added to the block (default: 0.99)\n#' @param merge_closeblock If TRUE merge adjecting block with similar haplotypes (default: FALSE)\n#' @param max_diff_l maximum number of windows with different haplotypes inbetween (default: 1)\n#' @param max_diff_i maximum number of individuals in only one of the two blocks (default: 1)\n#' @param min_majorblock minimum of positions in the dataset a block is the biggest covering (default: 50)\n#' @param consider_nodes Use nodes to identify blocks (default: TRUE)\n#' @param consider_edge Use edges between nodes to identify blocks (default: TRUE)\n#' @param edge_min minimum number of haplotypes per transition to use in consider_edge (default: 5)\n#' @param subgroups possible subgroups to consider in the block identification process (default: NULL - list(1:indi))\n#' @param min_per_subgroup minimum number of haplotypes per block per subgroup (default: 0)\n#' @param consider_all If TRUE always haplotypes which are not in the node to be in a generated block\n#' @param save_allblock If TRUE keep all haplotypes with all windows according to a block (even under min_similarity)\n#' @param block_extending If TRUE use the window-extending algorithm (step V)\n#' @param max_extending_diff Maximum number of windows with different realisation in the block-extending-algorithm\n#' @param extending_ratio Minimum Ratio between windows with one different realisation to multiple in block-extending-algorithm\n#' @param min_majorblock_steps Number of steps till full filtering with min_majorblock is done\n#' @param snp_extending If TRUE use the SNP-extending-algorithm (step V) (default: TRUE)\n#' @param max_extending_diff_snp Maximum number of SNPs with variants in SNP-extending-algorithm (step V; default: 0)\n#' @param extending_ratio_snp Minimum ratio of SNPs with only one allele to those with variants (default: Inf)#' @param off_node_addition If TRUE use off-variant-identification (default: FALSE)\n#' @param off_node_minimum_blocklength Minimum length of newly identified blocks (default: 10)\n#' @param off_node_minimum_blocksize Minimum number of individuals in newly identified blocks (default: 5)\n#' @param raster Raster-width in the identification step (default: 5; recommended to be lower than off_node_minimum_blocklength)\n#' @param major_snp_calculation If TRUE calculate for major allele for each SNP in each block (default:TRUE)\n#' @param off_node_addition If TRUE identify additional blocks in regions not covered by the window cluster (default: FALSE)\n#' @param prefilter If TRUE filter the dataset before detecting for block-structure (default: FALSE)\n#' @param maf Minimum minor allel frequency in prefilter (default: 0.05)\n#' @param equal_remove If TRUE filter out SNPs in perfect correlation to the next SNP (default: FALSE)\n#' @param big_output If TRUE return not only blocklist but also blockinfo, dataset ect.\n#' @param blockinfo_mode Structure of the groups in step I (default: 0 - Common haplos as major variants, 1- minimum number of groups)\n#' @param c_dhm_mode If TRUE use high speed calculation with C in block_merging (default: TRUE)\n#' @param intersect_func Selection of intersect function used in the computation (default: 2 - efficient C, 1- efficient R, 0- base::intersect)\n#' @param fast_compiler If TRUE use compiler-package to enableJIT(3) (default: TRUE)\n#' @param max_groups Maximum number of groups per window (adaptive window-size, default: 0 - use fixed window size)\n#' @param recoding If TRUE change allele coding (Major allele \"A\", Minor allele \"C\")\n#' @param recoding_notneeded Set to TRUE if dataset only contains \"A\", \"C\" to save comp. time\n#' @param consider_multi If TRUE use multi-level edges to identify blocks (default: FALSE)\n#' @param multi_min minimum number of haplotypes per multi transition to use in consider_multi (default: 5)\n#' @param blockinfo_mode_na Set TRUE for activation of NA-modelling\n#' @param actual_snp_weight Set weight for difference between two alleles in a SNP (more than 1 possible base pair)\n#' @param na_snp_weight Set weight for difference between NA and allele in a SNP (more than 1 possible base pair)\n#' @param na_seq_weight Set weight for difference between NA and allele a loci with 1 possible base pair\n#' @param weighting_length Weighting factor for length to determine major block (default: 1)\n#' @param weighting_size Weighting factor for number of haplotypes in block to determine major block (default: 1)\n#' @param target_coverage Target Coverage in the blocklist\n#' @param max_iteration Maximum number of iterations to archive target coverage\n#' @param min_step_size Minimum increase/decrase in min_block_size in target coverage fitting\n#' @param target_stop Stop fitting target coverage fitting early\n#' @param multi_window_mode Set TRUE so active the computation of multi window cluster with separate window_size/merging_error/min_share\n#' @param recalculate_biggest Set to FALSE to only calculate the number of major positions for those blocks that could be removed in each iteration (number of major blocks is only increasing when removing other blocks)\n#' @param adaptive_mode Set to TRUE to use the predefined adoptive mode ( window_size = c(5,10,20,50), target_coverage=0.9)\n#' @param developer_mode Set to TRUE to not delete internal computational stuff in the blocklist\n#' @export\n\nblock_calculation <- function(dhm, window_sequence=NULL, window_size=20, merging_error=1, node_min=5, gap=10,\n      min_share=0.975, off_lines=5, min_similarity=0.99, merge_closeblock=FALSE,\n      max_diff_l=1, max_diff_i=1, min_majorblock=5000, bp_map=NULL, window_anchor_gens=NULL,\n      consider_nodes=TRUE, consider_edge=TRUE, edge_min=5, subgroups=NULL, min_per_subgroup=0,\n      consider_all=TRUE, save_allblock=TRUE, block_extending=TRUE,\n      max_extending_diff=1, extending_ratio=20, min_majorblock_steps=4,\n      snp_extending=TRUE, max_extending_diff_snp=0, extending_ratio_snp=Inf,  major_snp_calculation=TRUE,\n      off_node_addition=FALSE, off_node_minimum_blocklength=10, off_node_minimum_blocksize=5,\n      raster=5, at_least_one=TRUE,\n      prefilter=FALSE, maf=0.00, equal_remove=FALSE,\n      big_output=FALSE, blockinfo_mode=0, c_dhm_mode=TRUE,\n      intersect_func=TRUE, fast_compiler=TRUE,\n      max_groups=0, recoding=FALSE, recoding_notneeded=FALSE,\n      consider_multi=FALSE, multi_min=5, blockinfo_mode_na=FALSE,\n      actual_snp_weight = 5, na_snp_weight=2, na_seq_weight=0,\n      weighting_length=1, weighting_size=1,\n      recalculate_biggest=TRUE,\n      target_coverage=NULL,\n      max_iteration=10,\n      min_step_size=25,\n      target_stop=0.001,\n      multi_window_mode=FALSE,\n      adaptive_mode=FALSE,\n      developer_mode=FALSE){\n\n  if(adaptive_mode==TRUE){\n    multi_window_mode <- TRUE\n    if(!(length(window_size)==1 && window_size==20)){\n      window_size <- c(5,10,20,50)\n    }\n    if(length(target_coverage)==0){\n      target_coverage <- 0.9\n    }\n  }\n  if(multi_window_mode==FALSE && (length(window_size)>1 || length(merging_error)>1 || length(min_share)>1)){\n    cat(\"Active multi_window_mode\")\n    multi_window_mode <- TRUE\n  }\n\n\n  if(multi_window_mode){\n    ncluster <- max(length(window_size), length(min_share), merging_error)\n    window_size <- rep(window_size,length.out=ncluster)\n    min_share <- rep(min_share, length.out=ncluster)\n    merging_error <- rep(merging_error, length.out=ncluster)\n  } else{\n    ncluster <- 1\n  }\n\n  if(merge_closeblock==TRUE && length(unique(window_size))){\n    merge_closeblock <- FALSE\n    cat(\"Closeblock-Merging only for single window size\\n\")\n  }\n\n  window_sequence_list <- list()\n\n  if(length(window_sequence)!=ncluster){\n    for(index in 1:ncluster){\n      window_sequence_list[[index]] <- window_sequence\n    }\n  } else{\n    window_sequence_list <- window_sequence\n  }\n  window_sequence_list[[ncluster+1]] <- \"placeholder\"\n\n\n\n  if(fast_compiler){\n    requireNamespace(\"compiler\")\n    enableJIT(3)\n\n  }\n\n  if(intersect_func){\n    intersect_func <- intersect_sortednumeric\n  } else{\n    intersect_func <- base::intersect\n  }\n\n  if(is.data.frame(dhm)){\n    dhm <- as.matrix(dhm)\n  }\n  if(sum(is.na(dhm))>0){\n    dhm[is.na(dhm)] <- 9\n  }\n\n  if(prefilter==TRUE){\n    dhm <- dataset_filter(dhm, maf, equal_remove)\n  }\n\n  if(recoding==TRUE){\n    if(recoding_notneeded==TRUE){\n      recoding <- TRUE\n    } else{\n      for(index in 1:nrow(dhm)){\n        check1 <- dhm[index,]==dhm[index,1]\n        dhm[index, check1] <- \"A\"\n        dhm[index, -(check1)*1:indi] <- \"C\"\n      }\n    }\n  }\n\n  # Martins Erweiterung\n  unique.dhm <- unique(as.vector(dhm))\n  fixcoding(unique.dhm)\n  c_dhm <- codeSNPs(dhm)\n\n  blockinfo <- list()\n  data <- list()\n  dataset <- list()\n  partial_blocklist <- list()\n  nwindow <- rep(0, ncluster)\n\n  for(index in 1:ncluster){\n    if(blockinfo_mode_na){\n      blockinfo_out <- blockinfo_calculation_na(dhm, window_sequence= window_sequence_list[[index]], window_anchor_gens = window_anchor_gens, blockinfo_mode=blockinfo_mode,\n                                              window_size = window_size[index], merging_error = merging_error[index], bp_map = bp_map, at_least_one=at_least_one,\n                                              actual_snp_weight=actual_snp_weight, na_snp_weight=na_snp_weight, na_seq_weight= na_seq_weight)\n\n    } else{\n      blockinfo_out <- blockinfo_calculation(dhm, window_sequence= window_sequence_list[[index]], window_anchor_gens = window_anchor_gens, blockinfo_mode=blockinfo_mode,\n                                              window_size = window_size[index], merging_error = merging_error[index], bp_map = bp_map, at_least_one=at_least_one,\n                                              c_dhm=c_dhm, max_groups=max_groups)\n\n    }\n\n    blockinfo[[index]] <- blockinfo_out[[1]]\n    window_sequence_list[[index]] <- blockinfo_out[[2]]\n\n\n    if(max_groups>0){\n      cat(paste(\"Generated:\", nrow(window_sequence_list[[index]]), \"windows\\n\"))\n      cat(paste(\"With size: Max\", max(window_sequence_list[[index]][,3]), \"Min\", min(window_sequence_list[[index]][,3]), \"Avg\", round(mean(window_sequence_list[[index]][,3])*100)/100),\"\\n\")\n    }\n\n    data[[index]] <- nodes_calculation(blockinfo[[index]], window_sequence_list[[index]])\n\n    data[[index]] <- simple_merge(data[[index]], intersect_func=intersect_func)\n    data[[index]] <- calculate_transition(data[[index]], intersect_func=intersect_func)\n\n\n      nwindow[index] <- nrow(window_sequence_list[[index]])\n      indi <- sum(blockinfo[[index]][[1]][[1]])\n      nodes <- length(data[[index]])\n      iteration <- 1\n      cat(\"Start_CrossMerging_full\\n\")\n      a <- start_end_block(data[[index]])\n      a_old <- NULL\n      while(length(a_old)==0 || (nrow(a_old)!=nrow(a)) || prod(a_old==a)==0){\n        a_old <- a\n        cat(paste(\"Iteration\", iteration, \":\", nodes, \"nodes\\n\"))\n        data[[index]] <- crossmerge(data[[index]], indi, nwindow[index], a, intersect_func=intersect_func)\n        data[[index]] <- simple_merge_prob(data[[index]], indi, nwindow[index])\n        a <- start_end_block(data[[index]])\n        nodes <- length(data[[index]])\n        iteration <- iteration + 1\n      }\n\n\n      nodes <- length(data[[index]])\n      iteration <- 1\n      cat(\"Start_IgnoreSmall\\n\")\n      while(iteration==1 || (nrow(a_old)!=nrow(a)) || prod(a_old==a)==0){\n        a_old <- a\n        cat(paste(\"Iteration\", iteration, \":\", nodes, \"nodes\\n\"))\n        data[[index]] <- ignore_small_nodes(data[[index]], indi, nwindow[index], node_min, gap, intersect_func=intersect_func)\n        data[[index]] <- simple_merge_prob(data[[index]], indi, nwindow[index], intersect_func=intersect_func)\n        data[[index]] <- crossmerge(data[[index]], indi, nwindow[index], intersect_func=intersect_func)\n        data[[index]] <- simple_merge_prob(data[[index]], indi, nwindow[index], intersect_func=intersect_func)\n        a<- start_end_block(data[[index]])\n        nodes <- length(data[[index]])\n        iteration <- iteration + 1\n      }\n\n    dataset[[index]] <- block_dataset_construction(blockinfo[[index]], indi, nwindow[index])\n\n    partial_blocklist[[index]] <- identify_blocks(data[[index]], indi, nwindow[index], min_share[index], edge_min=edge_min, subgroups=subgroups,\n                                                 consider_nodes=consider_nodes, consider_edge=consider_edge, min_per_subgroup=min_per_subgroup,\n                                                 intersect_func=intersect_func, consider_multi=consider_multi, multi_min=multi_min)\n  }\n\n  blocklist <- list()\n  for(index in 1:ncluster){\n    for(index2 in 1:length(partial_blocklist[[index]])){\n      blocklist[[length(blocklist)+1]] <- partial_blocklist[[index]][[index2]]\n      blocklist[[length(blocklist)]][[12]] <- index\n    }\n  }\n\n  # STRINGENZ ZU DATASET (ncol/nrow)\n\n\n  current_iteration <- max_iteration\n  if(length(target_coverage)>0){\n    current_iteration <- 1\n    blocklist_start <- blocklist\n    min_majorblock_count <- numeric(max_iteration)\n    coverage_results <- numeric(max_iteration)\n    min_majorblock_count[1] <- min_majorblock\n    blocklists <- list()\n\n  }\n  stop_iteration <- FALSE\n  while(current_iteration <= max_iteration && !stop_iteration){\n\n    if(length(target_coverage)>0){\n      min_majorblock <- min_majorblock_count[current_iteration]\n      blocklist <- blocklist_start\n    }\n\n    nodes <- length(blocklist)\n    iteration <- 1\n    cat(\"Start_Blockmerging\\n\")\n    helper <- blocklist_startend(blocklist, type=\"snp\")\n    helper_old <- NULL\n    while(length(helper_old)==0 || (nrow(helper_old)!=nrow(helper)) || prod(helper_old==helper)==0){\n      cat(paste(\"Iteration\", iteration, \":\", nodes, \"blocks\\n\"))\n      helper_old <- helper\n      blocklist <- block_merging(blocklist, blockinfo, dataset, dhm, indi, nwindow, window_sequence_list, off_lines, min_similarity=min_similarity,\n                                 consider_all=consider_all, node_min=node_min, save_allblock=save_allblock, helper=helper,\n                                 c_dhm=c_dhm, c_dhm_mode=c_dhm_mode, intersect_func=intersect_func,\n                                 min_per_subgroup=min_per_subgroup)\n\n      if(merge_closeblock==TRUE){\n        blocklist <- block_closeblock_merging(blocklist, blockinfo, indi, nwindow, max_diff_l, max_diff_i, intersect_func=intersect_func,\n                                              dataset=dataset)\n      }\n      if(min_majorblock>(0)){\n        if(min_majorblock_steps>1){\n          blocklist <- blockinfo_biggest(blocklist, nwindow, indi, min_majorblock=min(iteration-1, min_majorblock_steps-1)/(min_majorblock_steps-1)*min_majorblock,\n                                         weighting_length=weighting_length, weighting_size=weighting_size,\n                                         recalculate_biggest=recalculate_biggest, window_size=window_size)\n        } else{\n          blocklist <- blockinfo_biggest(blocklist, nwindow, indi, min_majorblock=min_majorblock, weighting_length=weighting_length, weighting_size=weighting_size,\n                                         recalculate_biggest=recalculate_biggest, window_size=window_size)\n        }\n      }\n      helper <- blocklist_startend(blocklist, type=\"snp\")\n      nodes <- length(blocklist)\n      iteration <- iteration + 1\n    }\n\n    if(block_extending==TRUE){\n      nodes <- length(blocklist)\n      iteration <- 1\n      extensions_done <- 0\n      cat(\"Start_Blockextending\\n\")\n      while(iteration==1 || (nrow(helper_old)!=nrow(helper)) || prod(helper_old==helper)==0 || extensions_done > 0){\n        helper_old <- helper\n        cat(paste(\"Iteration\", iteration, \":\", nodes, \"blocks; \", extensions_done, \"block extensions\\n\"))\n        blocklist_out <- extend_block(blocklist, indi, nwindow, max_extending_diff=max_extending_diff,\n                                      extending_ratio=extending_ratio, dataset=dataset, window_sequence_list=window_sequence_list)\n        blocklist <- blocklist_out[[1]]\n        extensions_done <- blocklist_out[[2]]\n\n        blocklist <- block_merging(blocklist, blockinfo, dataset, dhm, indi, nwindow, window_sequence_list, off_lines, min_similarity=min_similarity,\n                                   consider_all=consider_all, node_min=node_min, save_allblock=save_allblock, c_dhm=c_dhm,\n                                   c_dhm_mode=c_dhm_mode , intersect_func=intersect_func,\n                                   min_per_subgroup=min_per_subgroup)\n\n        if(merge_closeblock==TRUE){\n          blocklist <- block_closeblock_merging(blocklist, blockinfo, indi, nwindow, max_diff_l, max_diff_i, intersect_func=intersect_func,\n                                                dataset=dataset)\n        }\n        if(min_majorblock_steps>1){\n          blocklist <- blockinfo_biggest(blocklist, nwindow, indi, min_majorblock=min(iteration-1, min_majorblock_steps-1)/(min_majorblock_steps-1)*min_majorblock,\n                                         weighting_length=weighting_length, weighting_size=weighting_size,\n                                         recalculate_biggest=recalculate_biggest, window_size=window_size)\n        } else{\n          blocklist <- blockinfo_biggest(blocklist, nwindow, indi, min_majorblock=min_majorblock,\n                                         weighting_length=weighting_length, weighting_size=weighting_size,\n                                         recalculate_biggest=recalculate_biggest, window_size=window_size)\n        }\n\n        helper <- blocklist_startend(blocklist, type=\"snp\")\n        nodes <- length(blocklist)\n        iteration <- iteration + 1\n      }\n    }\n\n    if(snp_extending==TRUE){\n      # Fuege anfang und ende gleiche SNPs im Randbereich hinzu/ab\n      blocklist <- extend_snp(blocklist, indi, nwindow, dhm, window_sequence_list, bp_map = bp_map,\n                              max_extending_diff_snp=max_extending_diff_snp, extending_ratio_snp=extending_ratio_snp)\n\n    }\n\n\n\n    if(off_node_addition==TRUE){\n      print(\"OFF_node_addition Only for single nwindow\")\n      blocklist <- add_offnode(blocklist=blocklist, dataset[[1]], indi, nwindow[[1]], window_sequence=window_sequence_list[[1]], bp_map=bp_map,\n                               off_node_minimum_blocklength=off_node_minimum_blocklength,\n                               off_node_minimum_blocksize=off_node_minimum_blocksize, raster=raster)\n      nodes <- length(blocklist)\n      iteration <- 1\n      print(\"Start_Blockmerging\")\n      helper <- blocklist_startend(blocklist, type=\"snp\")\n      helper_old <- NULL\n      while(length(helper_old)==0 || (nrow(helper_old)!=nrow(helper)) || prod(helper_old==helper)==0){\n        print(paste(\"Iteration\", iteration, \":\", nodes, \"blocks\"))\n        helper_old <- helper\n        blocklist <- block_merging(blocklist, blockinfo, dataset, dhm, indi, nwindow, window_sequence_list, off_lines, min_similarity=min_similarity,\n                                   consider_all=consider_all, node_min=node_min, save_allblock=save_allblock, helper=helper,\n                                   c_dhm=c_dhm, c_dhm_mode=c_dhm_mode, intersect_func=intersect_func,\n                                   min_per_subgroup=min_per_subgroup)\n\n        if(merge_closeblock==TRUE){\n          blocklist <- block_closeblock_merging(blocklist, blockinfo, indi, nwindow, max_diff_l, max_diff_i, intersect_func=intersect_func,\n                                                dataset=dataset)\n        }\n        if(min_majorblock>(0)){\n          if(min_majorblock_steps>1){\n            blocklist <- blockinfo_biggest(blocklist, nwindow, indi, min_majorblock=min(iteration-1, min_majorblock_steps-1)/(min_majorblock_steps-1)*min_majorblock,\n                                           weighting_length=weighting_length, weighting_size=weighting_size,\n                                           recalculate_biggest=recalculate_biggest, window_size=window_size)\n          } else{\n            blocklist <- blockinfo_biggest(blocklist, nwindow, indi, min_majorblock=min_majorblock, weighting_length=weighting_length, weighting_size=weighting_size,\n                                           recalculate_biggest=recalculate_biggest, window_size=window_size)\n          }\n        }\n        helper <- blocklist_startend(blocklist, type=\"snp\")\n        nodes <- length(blocklist)\n        iteration <- iteration + 1\n      }\n\n      if(block_extending==TRUE){\n\n        nodes <- length(blocklist)\n        iteration <- 1\n        extensions_done <- 0\n        print(\"Start_Blockextending\")\n        while(iteration==1 || (nrow(helper_old)!=nrow(helper)) || prod(helper_old==helper)==0 || extensions_done > 0){\n          helper_old <- helper\n          print(paste(\"Iteration\", iteration, \":\", nodes, \"blocks; \", extensions_done, \"block extensions\"))\n          blocklist_out <- extend_block(blocklist, indi, nwindow, max_extending_diff=max_extending_diff,\n                                        extending_ratio=extending_ratio, dataset=dataset, window_sequence_list=window_sequence_list)\n          blocklist <- blocklist_out[[1]]\n          extensions_done <- blocklist_out[[2]]\n\n          blocklist <- block_merging(blocklist, blockinfo, dataset, dhm, indi, nwindow, window_sequence_list, off_lines, min_similarity=min_similarity,\n                                     consider_all=consider_all, node_min=node_min, save_allblock=save_allblock, c_dhm=c_dhm,\n                                     c_dhm_mode=c_dhm_mode , intersect_func=intersect_func,\n                                     min_per_subgroup=min_per_subgroup)\n\n          if(merge_closeblock==TRUE){\n            blocklist <- block_closeblock_merging(blocklist, blockinfo, indi, nwindow, max_diff_l, max_diff_i, intersect_func=intersect_func,\n                                                  dataset=dataset)\n          }\n          if(min_majorblock_steps>1){\n            blocklist <- blockinfo_biggest(blocklist, nwindow, indi, min_majorblock=min(iteration-1, min_majorblock_steps-1)/(min_majorblock_steps-1)*min_majorblock,\n                                           weighting_length=weighting_length, weighting_size=weighting_size,\n                                           recalculate_biggest=recalculate_biggest, window_size=window_size)\n          } else{\n            blocklist <- blockinfo_biggest(blocklist, nwindow, indi, min_majorblock=min_majorblock,\n                                           weighting_length=weighting_length, weighting_size=weighting_size,\n                                           recalculate_biggest=recalculate_biggest, window_size=window_size)\n          }\n\n          helper <- blocklist_startend(blocklist, type=\"snp\")\n          nodes <- length(blocklist)\n          iteration <- iteration + 1\n        }\n      }\n\n      if(snp_extending==TRUE){\n        # Fuege anfang und ende gleiche SNPs im Randbereich hinzu/ab\n        blocklist <- extend_snp(blocklist, indi, nwindow, dhm, window_sequence_list, bp_map = bp_map,\n                                max_extending_diff_snp=max_extending_diff_snp, extending_ratio_snp=extending_ratio_snp)\n\n      }\n\n\n    }\n\n    if(length(target_coverage)>0){\n\n      blocklists[[current_iteration]] <- blocklist\n      t <- coverage_test(blocklist, indi, type=\"snp\")\n      coverage_results[current_iteration] <- mean(t)\n      prev_cov <- coverage_results[coverage_results>0]\n      prev_block <- min_majorblock_count[min_majorblock_count>0]\n      if(min(prev_cov) > target_coverage){\n        min_majorblock_count[current_iteration + 1] <- max(max(prev_block)*2, max(prev_block)+min_step_size)\n      } else if(max(prev_cov) < target_coverage){\n        min_majorblock_count[current_iteration + 1] <- max(min(ceiling(min(prev_block)/2), min(prev_block) - min_step_size),1)\n      } else{\n        if(current_iteration==1){\n          stop_iteration <- TRUE\n        } else{\n          pos <- ((prev_cov-target_coverage)>0) * (1:length(prev_cov))\n          neg <- ((prev_cov-target_coverage)<0) * (1:length(prev_cov))\n          ordering <- sort(abs(prev_cov-target_coverage), index.return=TRUE)$ix\n          neg <- base::intersect(ordering, neg)\n          pos <- base::intersect(ordering, pos)\n          min_majorblock_count[current_iteration + 1] <- ceiling(mean(prev_block[c(pos[1], neg[1])]))\n        }\n\n      }\n      print(paste(\"Finish Target_Coverage Iteration\", current_iteration))\n      print(paste(\"Used min_majorblock:\", min_majorblock_count[current_iteration]))\n      print(paste(\"Achieved Coverage:\", coverage_results[current_iteration]))\n      if(current_iteration<max_iteration){\n        print(paste(\"Start next iteration using min_majorblock:\", min_majorblock_count[current_iteration+1]))\n      }\n\n      if(abs(coverage_results[current_iteration] - target_coverage)<target_stop){\n        stop_iteration <- TRUE\n      }\n\n\n\n\n    }\n    current_iteration <- current_iteration + 1\n\n  }\n\n  if(length(target_coverage)>0){\n    print(paste(\"Final Iteration using min_majorblock\",  min_majorblock_count[current_iteration-1]))\n    print(paste(\"Achieved Coverage:\", coverage_results[current_iteration-1]))\n    take <- which.max(-abs(coverage_results-target_coverage))[1]\n    blocklist <- blocklists[[take]]\n  }\n\n\n  if(major_snp_calculation==TRUE){\n    blocklist <- major_snp_calculation(blocklist, dhm, recoding=recoding)\n  }\n\n  if(!developer_mode){\n    if(big_output){\n      long_blocklist <- blocklist\n    }\n    for(index in 1:length(blocklist)){\n      blocklist[[index]][[12]] <- NULL\n      blocklist[[index]][[11]] <- NULL\n      blocklist[[index]][[10]] <- NULL\n      blocklist[[index]][[9]] <- NULL\n      blocklist[[index]][[8]] <- NULL\n    }\n  }\n\n  # Leere Blöcke - wesentlich kleinere Blöcke nicht direkt entfernen sondern verkleinerte versionen behalten.\n  if(big_output && developer_mode){\n    return(list(blocklist, dataset, data, blockinfo, indi, nwindow))\n  } else if(big_output){\n    return(list(blocklist, dataset, data, blockinfo, indi, nwindow, long_blocklist))\n  } else{\n    return(blocklist)\n  }\n\n}\n",
    "created" : 1507140520728.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1189629311",
    "id" : "E32F63E3",
    "lastKnownWriteTime" : 1525679061,
    "last_content_update" : 1525679061638,
    "path" : "C:/Users/tpook/Desktop/R-Stuff/HaploBlocker/R/block_calculation.R",
    "project_path" : "R/block_calculation.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "relative_order" : 9,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}