{
    "collab_server" : "",
    "contents" : "/*\n Authors\n Martin Schlather, schlather@math.uni-mannheim.de\n\n Copyright (C) 2017 -- Martin Schlather\n\nThis program is free software; you can redistribute it and/or\nmodify it under the terms of the GNU General Public License\nas published by the Free Software Foundation; either version 3\nof the License, or (at your option) any later version.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program; if not, write to the Free Software\nFoundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.\n*/\n\n\n//  #define LANDSLIDE 1\n//#include \"chb.h\"\n#include <inttypes.h> // uintptr_t\n#include \"chaploblocker.h\"\n#include \"zzz_CHaploblocker.h\"\n#include <R_ext/Rdynload.h>\n#include \"error.h\"\n#include <zzz_RandomFieldsUtils.h>\n\nCALL4(void, orderingInt, int*, data, int, len, int, dim, int *, pos)\n\n\n#define LOG std::log\n#define STRNCOPY std::strncpy // strncpy(dest, src, n\n#define CEIL(X) std::ceil((double) X) // keine Klammern um X!\n//#define STRNCMP std::strncmp\n\n#define BitsPerUnit 32\n#define Int int  // uint32_T\n// #define Int uint64_t\n#define BitsPerBlock 16\n#define MaxUserValues 256\n#define MaxChar 8\n\n#define START 0\n#define END 1\n#define CODENROW 2\n#define STARTREMAINDER 3\n#define ENDREMAINDER 4\n#define CODENCOL 5\n#define SNPxIND 6\n#define POSLAST SNPxIND\n\n\n#define Uint unsigned int\nUint bitsPerCode, codesPerUnit, leadingPattern, leadingShift,\n  MaxUserCodesPerBlock;\ntypedef enum {numeric, character, local} coding_type_def;\ncoding_type_def coding_type;\nbool BigEndian, // true iff 0x8000 -> [0] is != 0\n  allowexceptions = true;\n\nUint\n  ncodes = 0,\n  ONES = 0xFFFFFFFF;\nint *codes = NULL;\ntypedef char ZK[MaxChar +1];\nstatic ZK *strcodes = NULL,\n  ANY[2] = {\"@\", \"ANY\"}, //\"ANY\",\n  DUMMY = \"!;\";\n\nSEXP Position = R_NilValue,\n  Where = R_NilValue,\n  Counts = R_NilValue,\n  Codings = R_NilValue;\n\n#define BitsPerBlockValues (1 << BitsPerBlock)\nint unequal[BitsPerBlockValues];\n\nconst char namecodes[] = \"strings\", namestrcodes[] = \"numbers\";\n#define ENSURE(CODING) if (CODING == NULL) ERR1(\"Coding expected that contains %s only.\", name##CODING)\n\n\nvoid fixcodingSub(int nval) {\n  assert(BitsPerBlockValues >= MaxUserValues);\n  if (sizeof(int) != 4 ||\n      sizeof(short int) != 2 ||\n      BitsPerUnit != 32 ||\n      BitsPerBlock != 16\n      ) BUG;\n  if (nval > MaxUserValues)\n    ERR2(\"maximum number of 'values' is %d. Got %d.\", MaxUserValues, nval);\n\n // bitsPerCode sollen Bitlange von Int exakt teilen\n  // potentielle Verlust sollte irrelvant sein, da er nur fuer\n  // Zahl der values groesser 4 auftreten kann\n  if (nval < 2) {ERR(\"not enough values\");}\n  bitsPerCode =\n    1L << ((Uint) CEIL( LOG(LOG((double) nval) / LOG2) / LOG2));\n  codesPerUnit = (Uint) (BitsPerUnit / bitsPerCode);\n  assert(codesPerUnit * bitsPerCode == BitsPerUnit);\n  leadingShift = bitsPerCode * (codesPerUnit - 1);\n  leadingPattern = (ONES >> leadingShift) << leadingShift;\n\n  MaxUserCodesPerBlock = (int) (BitsPerBlock / bitsPerCode);\n  if (MaxUserCodesPerBlock * bitsPerCode != BitsPerBlock) BUG;\n\n  // determine how many unequals are in each code\n  for (Uint i = 0; i<BitsPerBlockValues; i++) {\n    Uint code = i << (BitsPerUnit - BitsPerBlock);\n    unequal[i] = 0;\n    for (Uint k=0; k<MaxUserCodesPerBlock; k++) {\n      unequal[i] += (code & leadingPattern) != 0;\n      code <<= bitsPerCode;\n    }\n    assert(unequal[i] <= (int) MaxUserCodesPerBlock);\n  }\n\n  if (Position == R_NilValue) Position = install(\"position\");\n  if (Codings == R_NilValue) Codings = install(\"codings\");\n  if (Counts == R_NilValue) Counts = install(\"counts\");\n  if (Where == R_NilValue) Where = install(\"where.to.find\");\n}\n\nvoid fixcodingIntern(int *values, int nval) {\n  if (codes != NULL) FREE(codes);\n  if (nval == 1) {\n    // strings !!!!\n    coding_type = local;\n    ncodes = std::abs(*values);\n    allowexceptions = *values > 0;\n  } else {\n    coding_type = numeric;\n    ncodes = nval;\n    codes = (int*) MALLOC(sizeof(int) * ncodes);\n    for (int i=0; i<(int) ncodes; i++) codes[i] = values[i];\n  }\n  fixcodingSub(ncodes);\n}\n\n\nvoid fixcodingIntern(SEXP values) {\n  coding_type = character;\n  int nval = length(values);\n  fixcodingSub(nval);\n  ncodes = nval;\n  if (strcodes != NULL) FREE(strcodes);\n  strcodes = (ZK*) MALLOC(sizeof(ZK) * nval);\n  for (int i=0; i<nval; i++) {\n    if (STRNCMP(ANY[1], CHAR(STRING_ELT(values, i)), MaxChar) == 0)\n      STRNCOPY(strcodes[i], ANY[0], MaxChar);\n    else STRNCOPY(strcodes[i], CHAR(STRING_ELT(values, i)), MaxChar);\n    strcodes[i][MaxChar] = '\\n';\n  }\n}\n\nSEXP fixcoding(SEXP values) {\n  if (TYPEOF(values) == STRSXP) fixcodingIntern(values);\n  else fixcodingIntern(INTEGER(values), length(values));\n  return R_NilValue;\n}\n\nvoid initHaploBlocker() {\n  union {\n    unsigned short a;\n    unsigned char b[2];\n  } ab;\n  ab.a = 0xFF00;\n  BigEndian = ab.b[0] != 0;\n  //  assert(!BigEndian);\n  int value = -2;\n  fixcodingIntern(&value, 1);\n  assert(codes != NULL || coding_type == local);\n}\n\nvoid redoCoding(SEXP M, int nrow, int ncol) {\n  //  printf(\"ncodes = %d\\n\", ncodes);\n  if (strcodes != NULL) FREE(strcodes);\n  strcodes = (ZK *) MALLOC(sizeof(ZK) * nrow * ncodes);\n  ZK *pcodes = strcodes;\n  int count[MaxUserValues];\n  for (int nr=0; nr<nrow; nr++, pcodes += ncodes) {\n    ZK temp[MaxUserValues];\n    int idx = nr,\n      order[MaxUserValues],\n      n=0;\n    for (int nc=0; nc<ncol; nc++, idx+=nrow) {\n      const char *m = CHAR(STRING_ELT(M, idx));\n      int i;\n      for (i=0; i<n; i++) {\n\tif (STRNCMP(temp[i], m, MaxChar) == 0) {\n\t  count[i]--;\n\t  break;\n\t}\n      }\n      if (i == n) { // not found\n\tif (n < MaxUserValues) {\n\t  STRNCOPY(temp[n], m, MaxChar);\n\t  temp[n][MaxChar] = '\\n';\n\t  count[n] = -1;\n\t} else {\n\t  if (!allowexceptions)\n\t    ERR1(\"maximal number of different entries per SNP reached. Setting 'fixcoding(%d)' is a way out.\", ncodes);\n\t  // else ignore what is coming up\n\t}\n\tn++;\n     }\n    }\n    RU_orderingInt(count, n, 1, order);\n    int i,\n      endfor = n >= (int) ncodes ? (int) ncodes : n;\n    for (i=0; i<endfor; i++) {\n      STRNCOPY(pcodes[i], temp[order[i]], MaxChar);\n      pcodes[i][MaxChar] = '\\n';\n    }\n    int k;\n    if (allowexceptions) {\n      k = (n >= (int) ncodes ? (int) ncodes - 1 : n);\n      STRNCOPY(pcodes[k], ANY[0], MaxChar);\n      pcodes[k][MaxChar] = '\\n';\n      k++;\n    } else k = i;\n    for (i=k; i<(int) ncodes; i++) STRCPY(pcodes[i], DUMMY);\n    //if (nr < 4) {for (i=0; i<k; i++) PRINTF(\"%s\", pcodes[i]); PRINTF(\"\\n\");}\n  }\n}\n\n\n\nvoid codeInner(SEXP M, Uint nrow, Uint ncol, Uint start, Uint *code, bool sXi\n\t       , int total\n\t       ) {\n\n  Uint\n    startremainder = start % codesPerUnit,\n    codenrow = 1 + (nrow + startremainder - 1) / codesPerUnit,//sxp x indiv\n     codencol = 1 + (ncol + startremainder - 1) / codesPerUnit,//not sxp x indiv\n    endk0 = codesPerUnit - startremainder;\n  ZK *pcodes = strcodes;\n  if (coding_type == local) pcodes += start * ncodes;\n\n#define LOOP(EQUAL, ENDOUTER, ENDINNER, CODEINCR, IINCR, IDXFACTOR, LASTI, NUM)\\\n    for (Uint nc=0; nc<ENDOUTER; nc++, code+=CODEINCR) {\t\t\\\n      int idx = nc * IDXFACTOR;\t\t\t\t\t\t\\\n      for (Uint i=0, n=0, endk = endk0; i<LASTI; i+=IINCR, endk=codesPerUnit){ \\\n\tif (false) printf(\"nc=%d i=%d in=%d out=%d last=%d itotal=%d\\n\", nc, i, ENDOUTER, ENDINNER, LASTI, total); \\\n\tassert(i < (Uint) total);\t\t\t\t\t\\\n\tcode[i] = 0;\t\t\t\t\t\t\t\\\n\tfor (Uint k=0; k<endk && n < ENDINNER; k++, n++, idx+=IINCR) {\t\\\n\t  if (false) { printf(\"idx=%d %d\\n\", idx, length(M));}\t\t\\\n\t  Uint l;\t\t\t\t\t\t\t\\\n\t  for (l=0; l<ncodes; l++) {\t\t\t\t\t\\\n\t    assert(idx < length(M));\t\t\t\t\t\\\n\t    bool equal = EQUAL;\t\t\t\t\t\t\\\n\t    if (false) printf(\"L=%d %d %d: %d %s %s\\n\", l, n, ncodes, equal, CHAR(STRING_ELT(M, idx)), pcodes[l + n * ncodes]); \\\n\t    if (equal) {\t\t\t\t\t\t\\\n\t      if (false && n>95 && ncol==1) printf(\"L=%d: %d %s %s\\n\", l, equal, CHAR(STRING_ELT(M, idx)), pcodes[l + n * ncodes]); \\\n\t      code[i] <<= bitsPerCode;\t\t\t\t\t\\\n\t      code[i] |= l;\t\t\t\t\t\t\\\n\t      break;\t\t\t\t\t\t\t\\\n\t    }\t\t\t\t\t\t\t\t\\\n\t  }\t\t\t\t\t\t\t\t\\\n\t  if (l >= ncodes) {\t\t\t\t\t\t\\\n\t    if (NUM) { ERR2(\"value '%d' is outside range of {0,..., %d}%\", \\\n\t\t\t    (int) m[idx], ncodes - 1);\t\t\t\\\n\t    } else {\t\t\t\t\t\t\t\\\n\t      Uint n_ncodes = n * ncodes;\t\t\t\t\\\n\t      if (coding_type == local &&\t\t\t\t\\\n\t\t!STRNCMP(pcodes[(ncodes - 1) + n_ncodes], DUMMY, MaxChar)) { \\\n\t\tassert(!allowexceptions);\t\t\t\t\\\n\t\tl=0;\t\t\t\t\t\t\t\\\n\t\twhile(STRNCMP(pcodes[l + n_ncodes], DUMMY, MaxChar)) l++; \\\n\t\tif (!false) printf(\"including %s at outer=%d l=%d (%s %s)\\n\", CHAR(STRING_ELT(M, idx)), n, l, pcodes[l-1 + n * ncodes], pcodes[l + n_ncodes]); \\\n\t\tSTRNCOPY(pcodes[l+n_ncodes], CHAR(STRING_ELT(M,idx)),MaxChar); \\\n\t\tpcodes[l + n_ncodes][MaxChar] = '\\n';\t\t\t\\\n\t\tcode[i] <<= bitsPerCode;\t\t\t\t\\\n\t\tcode[i] |= l;\t\t\t\t\t\t\\\n\t      } else {\t\t\t\t\t\t\t\\\n\t\tERR3(\"Not all SNP values (%dx%d) are recognized in %s coding.\",\\\n\t\t     n + 1, nc + 1, coding_type == local ? \"local\"\t\\\n\t\t     : coding_type == numeric ? \"numeric\" : \"character\" ); \\\n\t      }\t\t\t\t\t\t\t\t\\\n\t    }\t\t\t\t\t\t\t\t\\\n\t  }\t\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n      }\t\t\t\t\t\t\t\t\t\\\n       Uint nn = LASTI * codesPerUnit - ENDINNER - startremainder;\t\\\n      code[(LASTI - 1) * IINCR] <<=  (nn * bitsPerCode);\t\t\\\n    }\n\n#define EQU !STRNCMP(CHAR(STRING_ELT(M, idx)), pcodes[l], MaxChar) || !STRNCMP(ANY[0], pcodes[l], MaxChar);\n\n#define EQULOCAL !STRNCMP(CHAR(STRING_ELT(M, idx)), pcodes[l + n * ncodes], MaxChar) || !STRNCMP(ANY[0], pcodes[l + n * ncodes], MaxChar); //if (ncol==1 || true) { printf(\"nr=%d l=%d %s %s idx=%d\\n\", n, l, CHAR(STRING_ELT(M, idx)), pcodes[l + n * ncodes], l + n * ncodes); }\n\n  if (TYPEOF(M) == REALSXP) {\n    //    printf(\"%lu %lu\", (uintptr_t) codes, (uintptr_t) strcodes);\n    ENSURE(codes);\n    double *m = REAL(M);\n      if (sXi) LOOP(m[idx] == codes[l], ncol, nrow, codenrow, 1, nrow, codenrow,\n                    true)\n      else LOOP(m[idx] == codes[l], nrow, ncol, 1, nrow, 1, codencol, true)\n  } else if (TYPEOF(M) == INTSXP) {\n    ENSURE(codes);\n    int *m = INTEGER(M);\n    if (sXi) LOOP(m[idx] == codes[l], ncol, nrow, codenrow, 1, nrow, codenrow,\n                 true)\n      else LOOP(m[idx] == codes[l], nrow, ncol, 1, nrow, 1, codencol, true)\n  } else if (TYPEOF(M) == LGLSXP) {\n    ENSURE(codes);\n    int *m = LOGICAL(M);\n    if (sXi) LOOP(m[idx] == codes[l], ncol, nrow, codenrow, 1, nrow, codenrow,\n             true)\n    else LOOP(m[idx] == codes[l], nrow, ncol, 1, nrow, 1, codencol, true)\n  } else if (TYPEOF(M) == STRSXP) {\n    int *m = NULL;\n    ENSURE(strcodes);\n    if (coding_type == character) {\n      if (sXi) LOOP( EQU , ncol, nrow, codenrow, 1, nrow, codenrow, false)\n      else LOOP( EQU , nrow, ncol, 1, nrow, 1, codencol, false)\n    } else if (coding_type == local) {\n      if (sXi) LOOP( EQULOCAL , ncol, nrow, codenrow, 1, nrow, codenrow, false)\n      else LOOP( EQULOCAL, nrow, ncol, 1, nrow, 1, codencol, false)\n    } else ERR(\"coding type mismatch.\");\n  } else ERR(\"incompatible type of 'M'\");\n}\n\n/*\n+ }\n.ncodes = 7 start=0\nncodes = 7 start=5\n [1] 1364538113  337912914 1158873376  622998036 1141122100  859841602\n [7] 1376780595  621941522 1079136802 1428443714\n[1]        532 1141122100  859841602 1376780595  620756992\nattr(,\"position\")\n[1]  5 33  5  5  1\nE\n*/\n\nSEXP codeSNPs(SEXP M, SEXP Start, SEXP RedoCoding, SEXP SNPxINDIV) {\n  // M always starts from the very beginning\n  // start gives the shift for the coded M\n   if (length(M) == 0) return R_NilValue;\n  Uint ncol, nrow, codenrow, codencol,\n    start = INTEGER(Start)[0],\n    startremainder = start % codesPerUnit;\n  int size;\n  SEXP Code;\n  bool ismatrix = isMatrix(M),\n    snpxind = LOGICAL(SNPxINDIV)[0];\n\n  if (ismatrix) {\n    nrow = nrows(M);\n    ncol = ncols(M);\n  } else {\n    snpxind = true;\n    nrow = length(M);\n    ncol = 1;\n  }\n\n  if (snpxind) {\n    size = nrow;\n    codenrow = 1 + (nrow + startremainder - 1) / codesPerUnit;\n    codencol = ncol;\n    if (coding_type == local && LOGICAL(RedoCoding)[0] &&\n\t(strcodes == NULL || ncol > 1)) {\n      //printf(\"redoing %lu, %d\\n\", (uintptr_t) codes, ncol);\n      if (TYPEOF(M) != STRSXP) ERR(\"'redo = TRUE' (currently) only allowd for string valued matrices. If the option 'redo = TRUE' is needed for integer values matrices please contact the author.\");\n      //if (ncol == 1) ERR(\"'redo = TRUE', but a single SNP sequence is given\");\n      if (start != 0) ERR(\"recoding must start from the beginning (start=0).\");\n      redoCoding(M, nrow, ncol);\n    }\n  } else {\n    ERR(\"'idx x snp' currently disabled. Please contact author if needed.\");\n    size = ncol;\n    codencol = 1 + (ncol + startremainder - 1) / codesPerUnit;\n    codenrow = nrow;\n    if (coding_type == local && LOGICAL(RedoCoding)[0] && nrow > 1)\n      ERR(\"local recoding is not defined for individual x SNP matrices\");\n  }\n\n  if (ismatrix) PROTECT(Code = allocMatrix(INTSXP, codenrow, codencol));\n  else PROTECT(Code = allocVector(INTSXP, codenrow));\n  for (Uint i=0; i<codenrow * codencol; INTEGER(Code)[i++] = 0);\n\n  codeInner(M, nrow, ncol, start, (Uint*) INTEGER(Code), snpxind, codenrow * codencol);\n\n  SEXP Posvec;\n  PROTECT(Posvec = allocVector(INTSXP, POSLAST + 1));\n  int *posvec = INTEGER(Posvec);\n  posvec[START] = start; // first SNP in SNP sequence\n  //  posvec[END] = start + size - 1; // last SNP in SNP sequence\n  posvec[END] = start + size - 1; // last SNP in SNP sequence\n  posvec[CODENROW] = codenrow;// number of filled codes\n  posvec[CODENCOL] = codencol;// number of filled codes\n  posvec[SNPxIND] = snpxind;// number of filled codes\n  posvec[STARTREMAINDER] = startremainder;// first used position in code\n  posvec[ENDREMAINDER] = posvec[END] % codesPerUnit;\n  setAttrib(Code, Position, Posvec);\n  UNPROTECT(2);\n  return Code;\n}\n\n\nSEXP decodeSNPs(SEXP CM) {\n  SEXP Ans;\n  SEXP Pos = getAttrib(CM, Position);\n  int incr, cv_factor, k_factor,\n    k=0,\n    *pos = INTEGER(Pos),\n    type = coding_type == numeric ? INTSXP : STRSXP;\n  Uint  endnc,\n    size = pos[END] - pos[START] + 1,\n    codenrow = pos[CODENROW], // =nrows(CM) bzw length(CM)\n    codencol = pos[CODENCOL], // =nrows(CM) bzw length(CM)\n    startremainder = pos[STARTREMAINDER],\n    *cm  = (Uint*) INTEGER(CM);\n  bool snpxind = pos[SNPxIND];\n\n  if (snpxind) {\n    incr = 1;\n    endnc = codencol;\n    cv_factor = codenrow;\n    k_factor = size;\n  } else {\n    incr = codenrow;\n    endnc = codenrow;\n    cv_factor = 1;\n    k_factor = 1;\n  }\n\n  if (isMatrix(CM)) PROTECT(Ans = allocMatrix(type, snpxind ? size : codenrow,\n\t\t\t\t\t      snpxind ? codencol : size));\n  else PROTECT(Ans = allocVector(type, size));\n\n  //  printf(\"%lu %lu\\n\", (uintptr_t) codes,  (uintptr_t) strcodes);\n  if (coding_type == numeric) { ENSURE(codes); } else {  ENSURE(strcodes); }\n\n  for (Uint nc = 0; nc < endnc; nc++) {\n    Uint *cv = cm + nc * cv_factor,\n      pattern = leadingPattern >> (startremainder * bitsPerCode),\n      shift = leadingShift - startremainder * bitsPerCode;\n    ZK *pcodes = strcodes + pos[START] * ncodes;\n    k = nc * k_factor;\n    for (Uint i=0; i<size; i++, k+=incr) {\n      Uint idx = (*cv & pattern) >> shift;\n      if (idx >= ncodes) BUG;\n      if (coding_type == numeric) INTEGER(Ans)[k] = codes[idx];\n      else {\n\tSET_STRING_ELT(Ans, k, mkChar(pcodes[idx]));\n\tif (coding_type == local) pcodes += ncodes;\n      }\n      if (shift > 0) {\n\tpattern >>= bitsPerCode;\n\tshift -= bitsPerCode;\n      } else {\n\tpattern = leadingPattern;\n\tshift = leadingShift;\n\tcv+=incr;\n      }\n    }\n  }\n\n  UNPROTECT(1);\n  return Ans;\n}\n\n\nbool notequal(Uint *a, Uint *b, Uint c_start, Uint c_end, Uint startremainder,\n\t      Uint endremainder) {\n  Uint i = c_start;\n  if (c_start == c_end) {\n    //   printf(\":\");\n    Uint shift = startremainder * bitsPerCode;\n    return (((a[i] ^ b[i]) << shift)\n\t    >> (shift + (codesPerUnit - 1 - endremainder) * bitsPerCode)) != 0;\n  }\n  if ((a[i] ^ b[i]) << (startremainder * bitsPerCode)) return true;\n  for (i++; i<c_end; i++) if (a[i] != b[i]) return true;\n  if ((a[i] ^ b[i]) >> ((codesPerUnit - 1 - endremainder) * bitsPerCode))\n    return true;\n  return false;\n}\n\ntypedef struct pattern {\n  int where, ith, count;\n  pattern *next;\n} pattern;\n\n\n\n\nSEXP factorSNPs(SEXP CM, SEXP Start, SEXP End) {\n  SEXP Pos = getAttrib(CM, Position);\n  int *pos = INTEGER(Pos);\n  if (!pos[SNPxIND]) ERR(\"'factorSNPs' only defined for SNPxINDIVID matrices\");\n  if (INTEGER(Start)[0] < 0) ERR(\"value of 'start' must be positive.\");\n  Uint addtofirst,\n    start = (Uint) INTEGER(Start)[0],\n    end =  (Uint) INTEGER(End)[0],\n    c_start = start / codesPerUnit,\n    c_end = end / codesPerUnit,\n    startremainder = start % codesPerUnit,\n    endremainder = end % codesPerUnit,\n    *cm = ((Uint*) INTEGER(CM)),\n    *cur_cm = cm,\n    nrow = nrows(CM),\n    ncol = ncols(CM)\n    ;\n  short Uint *first,\n    SHORT_ONES = 0xFFFF,\n    firstpattern = SHORT_ONES;\n\n  SEXP Factor;\n  PROTECT(Factor = allocVector(INTSXP, ncol));\n\n  int\n     *factor = INTEGER(Factor),\n    ith = 0;\n\n#define tablelength (1 << (sizeof(*first) * 8))\n  pattern *patternTable[tablelength];\n  for (Uint i=0; i < tablelength; i++) patternTable[i] = NULL;\n  if (start > end) ERR(\"value of 'start' smaller than that of 'end'.\");\n  if ((int) end > pos[END]) ERR(\"value of 'end' outside the matrix 'CM'.\");\n\n  // where to base in hashing on\n  // c_end > c_start + 1 : easy, at least one filled word (word = short Uint)\n  // c_end == c_start : only the choice of two (lower or upper word)\n  // else : 4 choices (lower and upper word of c_start and c_end\n  if (c_end > c_start + 1) {\n    addtofirst = sizeof(Uint) / sizeof(short Uint);\n    assert(addtofirst == 2);\n  } else {\n    Uint shift,\n      in_start = codesPerUnit - startremainder,\n      in_end = endremainder + 1,\n      half = codesPerUnit / 2;\n    if (c_start == c_end) {\n      firstpattern = SHORT_ONES;\n      if (in_start < in_end) {\n\taddtofirst = BigEndian;\n\tshift = (half - in_start) * bitsPerCode;\n\tif (shift > 0)\n\t  firstpattern = ((firstpattern << shift) & SHORT_ONES) >> shift;\n\tassert(in_end >= half);\n\tshift = (codesPerUnit - in_end) * bitsPerCode;\n\tfirstpattern = (firstpattern >> shift) << shift;\n      } else {\n\t//\n\tassert(in_start >= half);\n\taddtofirst = 1 - BigEndian;\n\tshift = (codesPerUnit - in_start) * bitsPerCode;\n\tfirstpattern = ((firstpattern << shift) & SHORT_ONES) >> shift;\n\tshift = (half - in_end) * bitsPerCode;\n\tif (shift > 0) firstpattern = (firstpattern >> shift) << shift;\n      }\n    } else {\n      if (in_start >= half) addtofirst = BigEndian;\n      else if (in_end >= half) addtofirst = 2 + 1 - BigEndian;\n      else if (in_start >= in_end) {\n\taddtofirst = BigEndian;\n\tshift = (half - in_start) * bitsPerCode;\n\tfirstpattern = ((firstpattern << shift)  & SHORT_ONES) >> shift;\n      } else {\n\taddtofirst = 2 + 1 - BigEndian;\n\tshift = (half - in_end) * bitsPerCode;\n\tfirstpattern = (firstpattern >> shift) << shift;\n      }\n    }\n  }\n  for (Uint nc=0; nc<ncol; nc++, cur_cm += nrow) {\n    first  = ((short Uint*) (cur_cm + c_start) ) + addtofirst;\n    assert(*first < tablelength);\n    pattern **p = patternTable + (*first & firstpattern);\n    while (*p != NULL && notequal(cur_cm, cm + (*p)->where * nrow,\n\t\t\t\t  c_start, c_end,startremainder,endremainder)) {\n      p = &((*p)->next);\n    }\n    if (*p == NULL) {\n      *p = (pattern *) MALLOC(sizeof(pattern));\n      (*p)->where = nc;\n      (*p)->ith = ith++;\n      (*p)->count = 1;\n      (*p)->next = NULL;\n    } else ((*p)->count)++;\n    factor[nc] = (*p)->ith + 1;\n  }\n\n  SEXP WhereVec, CountsVec;\n  PROTECT(WhereVec = allocVector(INTSXP, ith));\n  PROTECT(CountsVec = allocVector(INTSXP, ith));\n  int *where = INTEGER(WhereVec),\n    *count = INTEGER(CountsVec);\n  for (Uint i=0; i < tablelength; i++) {\n    pattern *p = patternTable[i];\n    while (p != NULL) {\n      where[p->ith] = p->where + 1;\n      count[p->ith] = p->count;\n      pattern *q = p->next;\n      FREE(p);\n      p = q;\n    }\n  }\n  setAttrib(Factor, Where, WhereVec);\n  setAttrib(Factor, Counts, CountsVec);\n  UNPROTECT(3);\n  return Factor;\n}\n\n\n\n\nSEXP colSumsEqualSNPs(SEXP  CM, SEXP Start, SEXP CV, SEXP Select) {\n  SEXP Pos = getAttrib(CV, Position);\n  int *pos = INTEGER(Pos);\n  if (!pos[SNPxIND])\n    ERR(\"'colSumsEqualSNPs' only defined for SNPxINDIVID matrices\");\n  Uint *cm_orig = (Uint*)  INTEGER(CM),\n    *cv = (Uint*)  INTEGER(CV),\n    ncol_cv = isMatrix(CV) ? ncols(CV) : 1,\n    nrow_cv = isMatrix(CV) ? nrows(CV) : length(CV),\n    len = length(Select),\n    *select = len == 0 ? NULL : (Uint*) INTEGER(Select),\n    nrow = nrows(CM),\n    ncol = len == 0 ? ncols(CM) : len,\n    size =  (Uint) (pos[END] - pos[START] + 1),\n    start = INTEGER(Start)[0],\n    end =  start + size - 1,\n    c_start = start / codesPerUnit,\n    c_end = end / codesPerUnit,\n    startremainder = start % codesPerUnit,\n    endremainder = end % codesPerUnit,\n    startremainderBpC = startremainder * bitsPerCode,\n    endshift = ((codesPerUnit - 1 - endremainder) * bitsPerCode);\n  if (c_end > nrow)\n    ERR3(\"'V' too long (debugging info: length=%d start=%d nrow=%d)\",\n\t endremainder, start, c_end);\n\n  if (false) {\n    for (Uint nr=0; nr<nrow; nr++) {\n      for (Uint nc=0; nc<ncol; nc++) PRINTF(\"%8x \", cm_orig[nr + nc * nrow]);\n      PRINTF(\" %8x\\n\", cv[nr]);//\n    }\n    PRINTF(\"%d %d %d %d end=%d %d %d %d %d -- %d \\n\", startremainder, //\n\t   (Uint) pos[STARTREMAINDER],  endremainder, (Uint) pos[ENDREMAINDER],\n\t   end, codesPerUnit, start, size, pos[END], pos[START]);\n  }\n\n  if (startremainder != (Uint) pos[STARTREMAINDER] ||\n      endremainder != (Uint) pos[ENDREMAINDER]) BUG;\n\n  assert(CM != CV || ncol == ncol_cv);\n\n  union {\n    Uint d;\n    unsigned short int x[2];\n  } difference;\n  // do not delete next comment: started work 20 March 2018 with Torsten, see\n  // email to him\n  // bool ANYvalue = GLOBAL.blocker.ANY_diff_value != 0.0 ||\n  //    GLOBAL.blocker.ANY_allequal_value != 0.0;\n  //  int SXP = ANYvalue ? REALSXP : INTSXP;\n  int SXP = INTSXP;\n  SEXP Ans;\n  if (isMatrix(CV)) PROTECT(Ans = allocMatrix(SXP, ncol, ncol_cv));\n  else PROTECT(Ans = allocVector(SXP, ncol));\n\n  //do not delete next comment: started work 20 March 2018 with Torsten, see\n  // email to him\n  /*\n  if (ANYvalue) {\n    double *ans = REAL(Ans),\n      sizeD = (double) size;\n    for (Uint nc_cv = 0; nc_cv<ncol_cv; nc_cv++, cv += nrow_cv, ans += ncol_cv){\n      Uint *cm = cm_orig;\n      for (Uint nc = 0; nc < ncol; nc++, cm += nrow) {\n\tif (CM == CV && nc_cv > nc) { // quadratic & symmetric matrix !\n\t  ans[nc] = REAL(Ans)[nc * ncol + nc_cv];\n\t  continue;\n\t}\n\tUint sum_unequal,\n\t  i = c_start,\n\t  j = 0;\n\tif (select != NULL) // selection given\n\t  cm = cm_orig + (nrow * (select[nc] - 1)); // ueberschreibt cm+=nrow\n\tdifference.d = (cv[j] ^ cm[i]) << startremainderBpC;\n\tif (i == c_end) { // might happen for very small sizes\n\t  difference.d >>= startremainderBpC + endshift;\n\t  sum_unequal = unequal[difference.x[0]] + unequal[difference.x[1]];\n\t  ans[nc] = sizeD - sum_unequal;\n\t  continue;\n\t}\n\n\tsum_unequal = unequal[difference.x[0]] + unequal[difference.x[1]];\n\tfor (i++, j++ ; i<c_end; i++, j++) {\n\t  difference.d = cv[j] ^ cm[i];\n\t  sum_unequal += unequal[difference.x[0]] + unequal[difference.x[1]];\n\t}\n\tdifference.d = cv[j] ^ cm[i];\n\tdifference.d >>= endshift;\n\tsum_unequal += unequal[difference.x[0]] + unequal[difference.x[1]];\n\tans[nc] = sizeD - sum_unequal;\n      }\n    }\n } else\n    */\n  {\n    int *ans = INTEGER(Ans);\n    for (Uint nc_cv = 0; nc_cv<ncol_cv; nc_cv++, cv += nrow_cv, ans += ncol_cv){\n      Uint *cm = cm_orig;\n      for (Uint nc = 0; nc < ncol; nc++, cm += nrow) {\n\tif (CM == CV && nc_cv > nc) { // quadratic & symmetric matrix !\n\t  ans[nc] = INTEGER(Ans)[nc * ncol + nc_cv];\n\t  continue;\n\t}\n\tUint sum_unequal,\n\t  i = c_start,\n\t  j = 0;\n\tif (select != NULL) // selection given\n\t  cm = cm_orig + (nrow * (select[nc] - 1)); // ueberschreibt cm+=nrow\n\tdifference.d = (cv[j] ^ cm[i]) << startremainderBpC;\n\tif (i == c_end) { // might happen for very small sizes\n\t  difference.d >>= startremainderBpC + endshift;\n\t  sum_unequal = unequal[difference.x[0]] + unequal[difference.x[1]];\n\t  ans[nc] = size - sum_unequal;\n\t  continue;\n\t}\n\n\tsum_unequal = unequal[difference.x[0]] + unequal[difference.x[1]];\n\tfor (i++, j++ ; i<c_end; i++, j++) {\n\t  difference.d = cv[j] ^ cm[i];\n\t  sum_unequal += unequal[difference.x[0]] + unequal[difference.x[1]];\n\t}\n\tdifference.d = cv[j] ^ cm[i];\n\tdifference.d >>= endshift;\n\tsum_unequal += unequal[difference.x[0]] + unequal[difference.x[1]];\n\tans[nc] = size - sum_unequal;\n      }\n    }\n  }\n\n  UNPROTECT(1);\n  return Ans;\n}\n\n\n#define INTERSECT(INT1, INT2, INTEGER1, INTEGER2)\t\t\t\\\n  INT1 *a = INTEGER1(A);\t\t\t\t\t\t\\\n  INT2 *b = INTEGER2(B);\t\t\t\t\t\t\\\n  for (int i=0; i<lenA; i++) {\t\t\t\t\t\t\\\n    INT1 aa = a[i];\t\t\t\t\t\t\t\\\n    if (i > 0 && aa <= a[i-1]) { PRINTF(\"%d %d\\n\", (int) a[i-1], (int) aa); BUG;} \\\n    while (iB < lenB && b[iB] < aa) iB++;\t\t\t\t\\\n    if (iB == lenB) break;\t\t\t\t\t\t\\\n    if (aa == b[iB]) {\t\t\t\t\t\t\t\\\n      intersct[n++] = aa;\t\t\t\t\t\t\\\n      iB++;\t\t\t\t\t\t\t\t\\\n    }\t\t\t\t\t\t\t\t\t\\\n  }\n\n\nSEXP intersect(SEXP A, SEXP B){\n  //printf(\"%d %d %d %d\\n\", TYPEOF(A), TYPEOF(B), length(A), length(B));\n  int n = 0,\n    lenA = length(A),\n    lenB = length(B),\n    maxlen = lenA <= lenB ? lenA : lenB,\n    iB = 0;\n  if (lenA == 0 || lenB == 0) return allocVector(INTSXP, 0);\n  int\n    *intersct = (int*) MALLOC(sizeof(int) * maxlen);\n  SEXP Ans;\n  if (TYPEOF(A) == INTSXP) {\n    if (TYPEOF(B) == INTSXP) { INTERSECT(int, int, INTEGER, INTEGER); }\n    else { INTERSECT(int, double, INTEGER, REAL); }\n  } else {\n    if (TYPEOF(B) == INTSXP) { INTERSECT(double, int, REAL, INTEGER); }\n    else { INTERSECT(double, double, REAL, REAL); }\n  }\n  PROTECT(Ans = allocVector(INTSXP, n));\n  int *ans = INTEGER(Ans);\n  for (int i=0; i<n; i++) ans[i] = intersct[i];\n  FREE(intersct);\n  UNPROTECT(1);\n  return Ans;\n}\n",
    "created" : 1523605182405.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "4185463890",
    "id" : "FB9B45FF",
    "lastKnownWriteTime" : 1523605206,
    "last_content_update" : 1523605206428,
    "path" : "C:/Users/tpook/Desktop/R-Stuff/HaploBlocker/src/chaploblocker.cc",
    "project_path" : "src/chaploblocker.cc",
    "properties" : {
    },
    "relative_order" : 83,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "cpp"
}