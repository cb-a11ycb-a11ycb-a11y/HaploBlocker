{
    "collab_server" : "",
    "contents" : "#' Cross Merge nodes\n#'\n#' Internal Function perform a cross merge for node data\n#' @param data node-dataset\n#' @param indi number of haplotypes in the dataset\n#' @param nwindow number of windows in the dataset\n#' @param intersect_func Used intersect-function (internally relevant for computation time)\n#' @param a Internal helper for a efficient abort criterion\n#' @export\n\ncrossmerge <- function(data, indi, nwindow, a=NULL, intersect_func=intersect){\n\n  if(length(a)==0){\n    a <- start_end_block(data)\n  }\n\n  relevant <- (a[,1]>1) * (a[,2]<max(a[,2])) * (1:nrow(a))\n  relevant <- (1:nrow(a))[relevant]\n\n  while(length(relevant)>0){\n    index <- relevant[1]\n    if(data[[index]][[1]]$window >1 && data[[index]][[2]]$window <nwindow && data[[index]][[3]]>0){\n      eingang <- data[[index]][[7]][,1]\n      ausgang <- data[[index]][[6]][,1]\n    } else{\n      eingang <- ausgang <- NULL\n    }\n    if(length(eingang)>0 && length(ausgang)>0){\n      emerged <- numeric(length(eingang))\n      amerged <- numeric(length(ausgang))\n      for(index2 in 1:length(eingang)){\n        for(index3 in 1:length(ausgang)){\n\n          # Check Ob Ausgang/Eingang-Kombination Merge-Kandidat ist\n          if(amerged[index3]==0 && emerged[index2]==0){\n              activ_a <- ausgang[index3]\n              activ_e <- eingang[index2]\n              pos_a <- which(data[[index]][[6]][,1]==activ_a)\n              pos_e <- which(data[[index]][[7]][,1]==activ_e)\n              if(data[[index]][[6]][pos_a,2]== data[[index]][[7]][pos_e,2]){\n\n                # Bestimmung der Exakten Aus-und Eingangstiere\n                if(data[[index]][[7]][pos_e,1]==0){\n                  sonstige <- NULL\n                  if(pos_e>1){\n                    for(temp in 1:(pos_e-1)){\n                      sonstige <- c(sonstige, data[[data[[index]][[7]][temp,1]]][[5]])\n                    }\n                  }\n                  if(length(sonstige)>0){\n                    etier <- intersect_func((1:indi)[-sonstige], data[[index]][[5]])\n                  } else{\n                    etier <- data[[index]][[5]]\n                  }\n\n                } else{\n                  etier <- intersect_func(data[[data[[index]][[7]][pos_e,1]]][[5]], data[[index]][[5]])\n                }\n                if(data[[index]][[6]][pos_a,1]==0){\n                  sonstige <- NULL\n                  if(pos_a>1){\n                    for(temp in 1:(pos_a-1)){\n                      sonstige <- c(sonstige, data[[data[[index]][[6]][temp,1]]][[5]])\n                    }\n                  }\n                  if(length(sonstige)>0){\n                    atier <- intersect_func((1:indi)[-sonstige], data[[index]][[5]])\n                  } else{\n                    atier <- data[[index]][[5]]\n                  }\n\n                } else{\n                  atier <- intersect_func(data[[data[[index]][[6]][pos_a,1]]][[5]], data[[index]][[5]])\n                }\n\n                # Merge Knoten Wenn Aus/Eingangstiere Identisch\n                if(length(intersect_func(etier, atier))==max(length(atier), length(etier))){\n\n                  if(activ_a==0 && activ_e==0){\n                    # 1. Fall: Eingangsknoten 0, Ausgangsknoten 0 - Erstelle zusaetzlichen Knoten\n                    new_k <- length(data) +1\n                    data[[new_k]] <- data[[index]]\n                    data[[new_k]][[5]] <- atier\n                    data[[index]][[5]] <- intersect_func(data[[index]][[5]], (1:indi)[-atier])\n                    data[[new_k]][[3]] <- length(data[[new_k]][[5]])\n                    data[[index]][[3]] <- length(data[[index]][[5]])\n                    data[[new_k]][[6]] <- cbind(0,data[[new_k]][[3]])\n                    data[[new_k]][[7]] <- cbind(0,data[[new_k]][[3]])\n\n                    data[[index]] <- calculate_new_transition(data, index, nwindow, intersect_func=intersect_func)\n                    amerged[index3] <- 1\n                    emerged[index2] <- 1\n                  } else if(activ_a==0){\n                    # 2. Fall Eingangsknoten Existiert, Ausgangsknoten 0\n                    # Merge nur wenn auch alle Tiere im Eingangsknoten nach Index uebergehen.\n                    if(data[[activ_e]][[3]]==length(etier)){\n                      data[[activ_e]][[2]] <- data[[index]][[2]]\n                      data[[activ_e]][[4]] <- c(data[[activ_e]][[4]], data[[index]][[4]])\n                      data[[activ_e]][[6]] <- cbind(0,data[[activ_e]][[3]])\n\n                      data[[index]][[5]] <- intersect_func(data[[index]][[5]], (1:indi)[-etier])\n                      data[[index]][[3]] <- length(data[[index]][[5]])\n                      data[[index]] <- calculate_new_transition(data, index, nwindow, intersect_func=intersect_func)\n                      amerged[index3] <- 1\n                      emerged[index2] <- 1\n                    }\n                  } else if(activ_e==0){\n                    # 3. Fall Eingangsknoten existiert Nicht, Ausgangsknoten existiert und enthaelt Exakt knoten[index]\n                    # Merge analog zur 2.Fall nur wen alle Tiere uebergehen.\n                    if(length(atier)== data[[activ_a]][[3]]){\n                      data[[activ_a]][[1]] <- data[[index]][[1]]\n                      data[[activ_a]][[4]] <- c(data[[index]][[4]], data[[activ_a]][[4]])\n                      data[[activ_a]][[7]] <- cbind(0,data[[activ_a]][[3]])\n\n                      data[[index]][[5]] <- intersect_func(data[[index]][[5]], (1:indi)[-etier])\n                      data[[index]][[3]] <- length(data[[index]][[5]])\n                      data[[index]] <- calculate_new_transition(data, index, nwindow, intersect_func=intersect_func)\n                      amerged[index3] <- 1\n                      emerged[index2] <- 1\n                    }\n                  } else if(length(atier)== data[[activ_a]][[3]]){\n                    # 4. Fall Ein- und Ausgangsknoten existieren\n                    # saemtliche Tiere Aus Ausgangsknoten kommen aus knoten[index]\n                    data[[index]][[5]] <- intersect_func(data[[index]][[5]], (1:indi)[-etier])\n                    data[[activ_e]][[5]] <- intersect_func(data[[activ_e]][[5]], (1:indi)[-etier])\n                    data[[index]][[3]] <- length(data[[index]][[5]])\n                    data[[activ_e]][[3]] <- length(data[[activ_e]][[5]])\n                    data[[activ_a]][[1]] <- data[[activ_e]][[1]]\n                    data[[activ_a]][[4]] <- c(data[[activ_e]][[4]], data[[index]][[4]], data[[activ_a]][[4]])\n                    if(data[[activ_a]][[1]]$window>1){\n                      data[[activ_a]][[7]] <- data[[activ_e]][[7]] # Enthaelt alle moeglichen Eingaenge von activ_a und mehr!\n                    } else{\n                      data[[activ_a]][[7]] <- cbind(0,0)\n                    }\n                    data[[index]] <- calculate_new_transition(data,index,nwindow, intersect_func=intersect_func)\n                    data[[activ_e]] <- calculate_new_transition(data, activ_e, nwindow, intersect_func=intersect_func)\n                    data[[activ_a]] <- calculate_new_transition(data, activ_a, nwindow, intersect_func=intersect_func)\n                    amerged[index3] <- 1\n                    emerged[index2] <- 1\n                    # samtliche Knoten die knoten[activ_e] gehen nun in knoten[activ_a]\n                    recalc <- data[[activ_a]][[7]][,1]\n                    if(length(recalc[recalc>0])>0){\n                      for(rindex in recalc[recalc>0]){\n                        data[[rindex]] <- calculate_new_transition(data, rindex, nwindow, add_a = activ_a, intersect_func=intersect_func)\n                      }\n                    }\n                  } else if(length(atier)== data[[activ_e]][[3]]){\n                    # 5. Fall Ein- und Ausgangsknoten existieren\n                    # saemtliche Tiere im Eingangsknoten gehen in knoten[index]\n                    data[[index]][[5]] <- intersect_func(data[[index]][[5]], (1:indi)[-etier])\n                    data[[activ_a]][[5]] <- intersect_func(data[[activ_a]][[5]], (1:indi)[-etier])\n                    data[[index]][[3]] <- length(data[[index]][[5]])\n                    data[[activ_a]][[3]] <- length(data[[activ_a]][[5]])\n                    data[[activ_e]][[2]] <- data[[activ_a]][[2]]\n                    data[[activ_e]][[4]] <- c(data[[activ_e]][[4]], data[[index]][[4]], data[[activ_a]][[4]])\n                    data[[activ_e]][[6]] <- data[[activ_a]][[6]] # Enthaelt alle moeglichen Eingaenge von activ_a und mehr!\n                    data[[index]] <- calculate_new_transition(data,index,nwindow, intersect_func=intersect_func)\n                    data[[activ_e]] <- calculate_new_transition(data, activ_e, nwindow, intersect_func=intersect_func)\n                    data[[activ_a]] <- calculate_new_transition(data, activ_a, nwindow, intersect_func=intersect_func)\n                    amerged[index3] <- 1\n                    emerged[index2] <- 1\n\n                    # samtliche Knoten die knoten[activ_a] gehen nun in knoten[activ_e]\n                    recalc <- data[[activ_e]][[6]][,1]\n                    if(length(recalc[recalc>0])>0){\n                      for(rindex in recalc[recalc>0]){\n                        data[[rindex]] <- calculate_new_transition(data, rindex, nwindow, add_e = activ_e, intersect_func=intersect_func)\n                      }\n                    }\n\n                  }\n\n\n\n\n\n                }\n              }\n          }\n        }\n      }\n\n\n    }\n    relevant <- relevant[-1]\n  }\n  data <- renaming_combi(data, nwindow)\n}\n",
    "created" : 1524141151295.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2578338683",
    "id" : "70E8F701",
    "lastKnownWriteTime" : 1524216569,
    "last_content_update" : 1524216569,
    "path" : "C:/Users/tpook/Desktop/R-Stuff/HaploBlocker/R/crossmerge.R",
    "project_path" : "R/crossmerge.R",
    "properties" : {
        "source_window_id" : "",
        "tempName" : "Untitled1"
    },
    "relative_order" : 72,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}