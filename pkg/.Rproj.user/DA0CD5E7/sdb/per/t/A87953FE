{
    "collab_server" : "",
    "contents" : "#' Identify possible blocks base on the node-dataset\n#'\n#' Function to identify possible blocks base on the node-dataset\n#' @param data node-dataset\n#' @param indi number of haplotypes in the dataset\n#' @param nwindow number of windows in the dataset\n#' @param min_share minimum percentage of transition to the same block for extension (default: 0.95, step III)\n#' @param consider_nodes Use nodes to identify blocks (default: TRUE)\n#' @param consider_edge Use edges between nodes to identify blocks (default: TRUE)\n#' @param edge_min minimum number of haplotypes per transition to use in consider_edge (default: 5)\n#' @param subgroups possible subgroups to consider in the block identification process (default: NULL - list(1:indi))\n#' @param min_per_subgroup minimum number of haplotypes per block per subgroup (default: 0)\n#' @param subgroup_exception allow for not all subgroups to include a block\n#' @param intersect_func Used intersect-function (internally relevant for computation time)\n#' @param identify_filter If TRUE filter out Starting blocks to avoid duplicated (default: FALSE)\n#' @param consider_multi If TRUE use multi-level edges to identify blocks (default: FALSE)\n#' @param multi_min minimum number of haplotypes per multi transition to use in consider_multi (default: 5)\n#' @export\n\nidentify_blocks <- function(data, indi, nwindow, min_share=0.95, consider_nodes=TRUE, consider_edge=TRUE,\n                            edge_min=5, subgroups=NULL, min_per_subgroup= 0, intersect_func=intersect,\n                            identify_filter=FALSE, consider_multi=FALSE,\n                            multi_min=5, subgroup_exception=0){\n  if(length(subgroups)==0){\n    subgroups <- list(1:indi)\n  }\n  b <- nodes_size(data) # Individuen pro Block\n  blocklist <- list()\n  blockcounter <- 1\n  activ_blocks <- NULL\n  if(min_per_subgroup>0){\n    identify_subgroups <- list(sort(unique(unlist(subgroups))))\n  } else{\n    identify_subgroups <- subgroups\n  }\n  for(start in 1:length(data)){\n    options <- list()\n    if(consider_nodes==TRUE){\n      if(nrow(data[[start]][[7]])>1 || (nrow(data[[start]][[7]])==1 && data[[start]][[7]][1,1]==0) || (nrow(data[[start]][[7]])==1 && nrow(data[[data[[start]][[7]][1,1]]][[6]])>=2)){\n        for(group in identify_subgroups){\n          options[[length(options)+1]] <- list(start, data[[start]][[4]], intersect_func(data[[start]][[5]], group))\n        }\n      }\n    }\n    if(consider_edge==TRUE){\n      valid <- data[[start]][[6]][(data[[start]][[6]][,2]>=edge_min) * (data[[start]][[6]][,1]>0) * 1:nrow(data[[start]][[6]]),1]\n      if((nrow(data[[start]][[6]])!=1 && data[[start]][[6]][1,1]!=0 ) || consider_nodes==FALSE){\n        if(length(valid)>0){\n          for(index in valid){\n            for(group in identify_subgroups){\n              options[[length(options)+1]] <- list(c(start), c(data[[start]][[4]]), intersect_func(group, intersect_func(data[[start]][[5]], data[[index]][[5]])) )\n            }\n          }\n        }\n      }\n    }\n    if(consider_multi==TRUE){\n      valid <- data[[start]][[6]][(data[[start]][[6]][,2]>=edge_min) * (data[[start]][[6]][,1]>0) * 1:nrow(data[[start]][[6]]),1]\n      if((nrow(data[[start]][[6]])!=1 && data[[start]][[6]][1,1]!=0 ) || consider_nodes==FALSE){\n        if(length(valid)>0){\n          for(index in valid){\n            valid2 <- data[[index]][[6]][(data[[index]][[6]][,2]>=edge_min) * (data[[index]][[6]][,1]>0) * 1:nrow(data[[index]][[6]]),1]\n\n            if((nrow(data[[index]][[6]])!=1 && data[[index]][[6]][1,1]!=0 ) || consider_nodes==FALSE){\n              if(length(valid2)>0){\n                for(index2 in valid2){\n                  for(group in identify_subgroups){\n                    options[[length(options)+1]] <- list(c(start), c(data[[start]][[4]]), intersect_func(intersect_func(group, intersect_func(data[[start]][[5]], data[[index]][[5]])), data[[index2]][[5]]))\n                    if(length(options[[length(options)]][[3]])<multi_min){\n                      options[[length(options)]] <- NULL\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n\n    }\n\n    if(min_per_subgroup>0){\n      if(length(options)>0){\n        for(index in length(options):1){\n          checker <- 1\n          exception <- subgroup_exception\n          for(group in subgroups){\n            if(min_per_subgroup> length(intersect_func(group, options[[index]][[3]]))){\n              exception <- exception -1\n              if(exception<0){\n                checker <- 0\n              }\n            }\n          }\n          if(checker==0){\n            options[[index]] <- NULL\n          }\n        }\n      }\n    } else{\n      for(index in length(options):1){\n        if(length(options[[index]][[3]])==0){\n          options[[index]] <- NULL\n        }\n      }\n    }\n\n    if(identify_filter){\n      if(length(options)>0){\n        for(index in length(options):1){\n          candidates <- which(activ_blocks[,4]==length(options[[index]][[3]]))\n          for(check in candidates){\n            if(prod(options[[index]][[3]]==blocklist[[activ_blocks[check,3]]][[6]])){\n              options[[index]] <- NULL\n              break\n\n            }\n          }\n        }\n      }\n\n      # Hier werden optionen aussortiert!\n    }\n\n    for(option in options){\n      block <- option[[1]]\n      windows <- option[[2]]\n      individuen <- option[[3]]\n      checker1 <- 1\n      checker2 <- 1\n\n      last <- start\n      first <- start\n\n      while((checker1+checker2)>0){\n        if(checker1==1){\n          last.last <- last\n          if(data[[last]][[2]]$window <nwindow){\n            possible <- unique(c(0, data[[last]][[6]][,1]))[-1]\n            for(xyz in possible){\n              anteil <- length(intersect_func(individuen, data[[xyz]][[5]]))/length(individuen)\n              subgroup_stop <- 1\n              if(min_per_subgroup>0){\n                exception <- subgroup_exception\n                for(groups in subgroups){\n                  anzahl <- length(intersect_func(intersect_func(individuen,data[[xyz]][[5]] ), groups))\n                  if(anzahl<min_per_subgroup){\n                    exception <- exception -1\n                    if(exception<0){\n                      subgroup_stop <- 0\n                    }\n                  }\n                }\n              }\n              if(subgroup_stop==1 && anteil >= min_share){\n                block <- c(block, xyz)\n                windows <- c(windows, data[[xyz]][[4]])\n                last <- xyz\n                individuen <- intersect_func(individuen, data[[xyz]][[5]])\n              }\n            }\n            if(last.last==last) checker1 <- 0\n          } else{\n            checker1 <- 0\n          }\n\n        }\n\n        if(checker2==1){\n          last.first <- first\n          if(data[[first]][[1]]$window>1){\n            possible <- unique(c(0, data[[first]][[7]][,1]))[-1]\n            for(xyz in possible){\n              anteil <- length(intersect_func(individuen, data[[xyz]][[5]]))/length(individuen)\n              subgroup_stop <- 1\n              if(min_per_subgroup>0){\n                exception <- subgroup_exception\n                for(groups in subgroups){\n                  anzahl <- length(intersect_func(intersect_func(individuen,data[[xyz]][[5]] ), groups))\n                  if(anzahl<min_per_subgroup){\n                    exception <- exception -1\n                    if(exception<0){\n                      subgroup_stop <- 0\n                    }\n                  }\n                }\n              }\n              if(subgroup_stop==1 && anteil >= min_share){\n                block <- c(xyz,block)\n                windows <- c(data[[xyz]][[4]], windows)\n                first <- xyz\n                individuen <- intersect_func(individuen, data[[xyz]][[5]])\n              }\n            }\n            if(last.first==first) checker2 <- 0\n          } else{\n            checker2 <- 0\n          }\n\n        }\n\n      }\n      # Verlaengerung Nach Hinten\n\n\n\n      blocklist[[blockcounter]] <- list()\n      blocklist[[blockcounter]][[1]] <- block\n      blocklist[[blockcounter]][[2]] <- data[[min(block)]][[1]]\n      blocklist[[blockcounter]][[3]] <- data[[max(block)]][[2]]\n      blocklist[[blockcounter]][[4]] <- windows\n      blocklist[[blockcounter]][[6]] <- individuen\n      blocklist[[blockcounter]][[5]] <- length(individuen)\n      blockcounter <- blockcounter + 1\n    }\n\n    if(identify_filter){\n      activ_blocks <- activ_blocks[activ_blocks[,2]>=data[[start]]$end$window,]\n      if(length(options)>0){\n        activ_blocks <- rbind(activ_blocks, cbind(blocklist_startend(blocklist, first_block = length(blocklist)- length(options)+1), (length(blocklist)- length(options)+1):length(blocklist), blocklist_size(blocklist, first_block = length(blocklist)- length(options)+1)))\n      }\n    }\n  }\n\n  return(blocklist)\n}\n",
    "created" : 1524140098594.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "805437290",
    "id" : "A87953FE",
    "lastKnownWriteTime" : 1527072664,
    "last_content_update" : 1527072664479,
    "path" : "C:/Users/tpook/Desktop/R-Stuff/HaploBlocker/R/identify_blocks.R",
    "project_path" : "R/identify_blocks.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "relative_order" : 64,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}