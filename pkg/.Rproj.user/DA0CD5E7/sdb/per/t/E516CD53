{
    "collab_server" : "",
    "contents" : "#' Plot Block_structure\n#'\n#' Function to create a graphical representation of the blocklist\n#' @param oriantation Position on with to sort haplotypes for similarity (default: \"snp\", options: \"front\", \"mid\",\"back\")\n#' @param snp_ori Select SNP for the oriantation algorithm if oriantation==\"snp\"\n#' @param export_order Export the chosen haplotype order after sorting\n#' @param import_order Import a given haplotype order\n#' @param min_to_plot Only include blocks with at least this many haplotypes in it (default:5)\n#' @param intensity Color-intensity for the plotted blocks (default: 0.5 (options: 0-1))\n#' @param include Include haplotypes in no block in the oriantation position in the graph\n#' @param indi number of haplotypes in the dataset\n#' @param type length measure (default: \"window\" , alt: \"snp\", \"bp\")\n#' @param max_step Maximum distance of blocks to consider in the oriantation step (default: 500)\n#' @param blocklist block-dataset\n#' @param add_sort If FALSE deactivate sorting haplotype for local similarity\n#' @export\n\n\nplot_block <- function(blocklist, type=\"snp\", oriantation=\"snp\", include=TRUE, indi=NULL, min_to_plot = 5,\n                      intensity=0.5, add_sort=TRUE, max_step=500,\n                      snp_ori=NULL,\n                      export_order=FALSE, import_order=FALSE){\n\n  if(length(indi)==0){\n    indi <- indi_calc(blocklist)\n  }\n\n  oriantation_f <- oriantation\n  se <- blocklist_startend(blocklist, type=type)\n  order <- NULL\n\n  if(length(oriantation_f)==0){\n    order <- 1:indi\n  } else if(oriantation_f[1]==\"front\"){\n    oriantation <- 1:8\n  } else if(oriantation_f[1]==\"mid\"){\n    oriantation <- 1:8 + ceiling(nrow(se)/2-3)\n  } else if(oriantation_f[1]==\"back\"){\n    oriantation <- 1:8 + nrow(se) -8\n  } else if(oriantation_f[1]==\"snp\"){\n    if(length(snp_ori)==0){\n      snp_ori <- mean(c(max(se), min(se)))\n    }\n    oriantation <- which(((se[,1]<= snp_ori)+ (se[,2]>= snp_ori))==2)\n  } else{\n    order <- oriantation_f\n  }\n\n  if(length(oriantation)>0 && import_order==FALSE){\n    sorted <- oriantation[1]\n    oriantation <- oriantation[-1]\n    while(length(oriantation)>0){\n      overlap <- numeric(length(oriantation))\n      actives <- blocklist[[sorted[length(sorted)]]][[6]]\n      i1 <- 1\n      for(index in oriantation){\n        nextone <- blocklist[[index]][[6]]\n        overlap[i1] <- length(intersect(nextone,actives))/ length(nextone)\n        i1 <- i1 + 1\n      }\n      sorted <- c(sorted, oriantation[which.max(overlap)[1]])\n      oriantation <- oriantation[-which.max(overlap)[1]]\n    }\n    oriantation <- sorted\n\n  }\n  if(length(order)==0){\n    if(include==TRUE){\n      oriantation <- c(oriantation, 0)\n    }\n    for(index in oriantation){\n      pl <- length(order)\n      if(index==0){\n        order <- unique(c(order,1:indi))\n        index <- ceiling(median(oriantation[-length(oriantation)]))\n      } else{\n        order <- unique(c(order,blocklist[[index]][[6]]))\n      }\n\n      if(add_sort==TRUE && length(order)>pl){\n        if(pl>0){\n          added <- order[-(1:pl)]\n        } else{\n          added <- order\n        }\n        groups <- list()\n        groups[[1]] <- added\n        for(step in 1:max_step){\n\n          if(length(groups)<length(added)){\n            if((index-step) >0 && length(intersect(blocklist[[index-step]][[6]], added))>0){\n              new_groups <- list()\n              for(group in 1:length(groups)){\n                same <- base::intersect(groups[[group]], blocklist[[index-step]][[6]])\n                rest <- base::intersect(groups[[group]], (1:indi)[-blocklist[[index-step]][[6]]])\n                if(length(same)>0){\n                  new_groups[[length(new_groups)+1]] <- same\n                }\n                if(length(rest)>0){\n                  new_groups[[length(new_groups)+1]] <- rest\n                }\n\n              }\n              groups <- new_groups\n            }\n            if((index+step) <=length(blocklist) && length(intersect(blocklist[[index+step]][[6]], added))>0){\n              new_groups <- list()\n              for(group in 1:length(groups)){\n                same <- base::intersect(groups[[group]], blocklist[[index+step]][[6]])\n                rest <- base::intersect(groups[[group]], (1:indi)[-blocklist[[index+step]][[6]]])\n                if(length(same)>0){\n                  new_groups[[length(new_groups)+1]] <- same\n                }\n                if(length(rest)>0){\n                  new_groups[[length(new_groups)+1]] <- rest\n                }\n\n\n              }\n              groups <- new_groups\n            }\n          }\n\n        }\n        if(pl>0){\n          order <- c(order[(1:pl)],unlist(groups))\n        } else{\n          order <- c(unlist(groups))\n        }\n\n      }\n    }\n\n\n  }\n  plot(0,-1000,ylim=c(0,length(order)), xlim=c(1,max(se)), ylab=\"haplotype\", xlab=\"SNP\",\n       cex.axis=1, cex.lab=1)\n\n  activ_colors <- numeric(length(blocklist))\n  for(index in 1:length(blocklist)){\n    overlap <- duplicated(c(blocklist[[index]][[6]], order))[-(1:blocklist[[index]][[5]])]\n    if(sum(overlap) >= min_to_plot){\n      taken <- base::intersect(which(se[,1]<=se[index,2]), which(se[,2]>=se[index,1]))\n      block_color <- sort(unique(c(0,activ_colors[taken])))\n      activ_colors[index] <- min(length(block_color),which(block_color!=(1:length(block_color)-1))-1)\n      for(index2 in which(overlap)){\n        polygon(c(se[index,1], se[index,2], se[index,2], se[index,1]), index2-c(1,1,0,0),\n                col=adjustcolor(activ_colors[index],alpha.f=intensity), lty=0)\n      }\n    }\n  }\n  if(export_order==TRUE){\n    return(order)\n  }\n}\n",
    "created" : 1512058188263.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3805864292",
    "id" : "E516CD53",
    "lastKnownWriteTime" : 1527592941,
    "last_content_update" : 1527592941071,
    "path" : "C:/Users/tpook/Desktop/R-Stuff/HaploBlocker/R/plot_block.R",
    "project_path" : "R/plot_block.R",
    "properties" : {
        "tempName" : "Untitled37"
    },
    "relative_order" : 15,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}