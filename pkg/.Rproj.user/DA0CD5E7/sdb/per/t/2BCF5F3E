{
    "collab_server" : "",
    "contents" : "#' Ignore small nodes\n#'\n#' Internal Function remove windows which transition to less frequent haplotypes in adjecent windows\n#' @param data node-dataset\n#' @param indi number of haplotypes in the dataset\n#' @param nwindow number of windows in the dataset\n#' @param min_node minimum number of haplotypes per block (default: 5)\n#' @param gap remove haplotypes in nodes adjacent to nodes with less than minimim_blocksize haplotypes in it (default: 10 windows)\n#' @param intersect_func Used intersect-function (internally relevant for computation time)\n#' @export\n\nignore_small_nodes <- function(data, indi , nwindow, min_node=5, gap=10, intersect_func=intersect){\n  resttiere <- matrix(0, nrow=indi, ncol=nwindow)\n\n  for(index in 1:length(data)){\n    if(data[[index]][[3]]< min_node){\n      resttiere[data[[index]][[5]], data[[index]][[1]]$window:data[[index]][[2]]$window] <- 1\n      data[[index]][[3]] <- 0\n      data[[index]][[5]] <- numeric(0)\n\n      if(data[[index]][[2]]$window<nwindow){\n        next1 <- unique(c(0,data[[index]][[6]][,1]))[-1]\n        for(index2 in next1){\n          data[[index2]] <- calculate_new_transition(data, index2, nwindow, intersect_func=intersect_func)\n        }\n      }\n\n\n      if(data[[index]][[1]]$window>1){\n        previous1 <- unique(c(0,data[[index]][[7]][,1]))[-1]\n        for(index2 in previous1){\n          data[[index2]] <- calculate_new_transition(data, index2, nwindow, intersect_func=intersect_func)\n        }\n      }\n\n    }\n  }\n\n\n\n\n  # Additional 0er\n  checker <- matrix(0, nrow=indi, ncol=nwindow)\n\n  for(index in 1:indi){\n    ones <- which(resttiere[index,]==1)\n    if(sum(ones)>0){\n      diff <- ones[-1] -ones[-length(ones)]\n      reaction <- unique(c(0,((diff < gap) & (diff>1)) *(1:length(diff))))[-1]\n      for(change in reaction){\n        checker[index, (ones[change]+1):(ones[change+1]-1)] <- 1\n      }\n      if(ones[1]< gap && ones[1]>1){\n        checker[index, 1:ones[1]] <- 1\n      }\n      if(ones[length(ones)]> (nwindow-gap+1) && ones[length(ones)]<nwindow){\n        checker[index, (ones[length(ones)]+1):nwindow] <- 1\n      }\n    }\n  }\n\n\n  block1 <- matrix(0, nrow=indi, ncol=nwindow)\n  for(index in 1:length(data)){\n    block1[data[[index]][[5]], data[[index]][[1]]$window: data[[index]][[2]]$window] <- index\n  }\n\n\n  abc <- unique(c(0,block1 * checker))[-1]\n\n  for(index in abc){\n    removes <- which(checker[,data[[index]][[1]]$window]==1)\n    data[[index]][[5]] <- intersect_func(data[[index]][[5]], (1:indi)[-removes])\n    data[[index]][[3]] <- length(data[[index]][[5]])\n    data[[index]] <- calculate_new_transition(data, index, nwindow, intersect_func=intersect_func)\n  }\n\n  data <-renaming_combi(data, nwindow)\n\n  return(data)\n\n}\n",
    "created" : 1524140891317.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3759096936",
    "id" : "2BCF5F3E",
    "lastKnownWriteTime" : 1524235556,
    "last_content_update" : 1524235556099,
    "path" : "C:/Users/tpook/Desktop/R-Stuff/HaploBlocker/R/ignore_small_nodes.R",
    "project_path" : "R/ignore_small_nodes.R",
    "properties" : {
    },
    "relative_order" : 66,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}