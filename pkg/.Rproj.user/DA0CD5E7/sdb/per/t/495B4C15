{
    "collab_server" : "",
    "contents" : "#' Mainfunction to calculate haplotype blocks\n#'\n#' Function to generate haplotype blocks from haploid data\n#' @param dhm haploid SNP-dataset\n#' @param c_dhm Bit-wise coded SNP-dataset\n#' @param window_size size of each window in the algorithm (default: 20)\n#' @param merging_error number of allowed errors per block (default: 1)\n#' @param window_sequence sequence of predefined windows (default: NULL ;per row: start$snp, end$snp, length, length - merging_error, start$bp, end$bp)\n#' @param bp_map vector of positions for each SNP in bp (default: NULL - all 0)\n#' @param window_anchor_gens matrix to constructed window_sequence base on start/end points in bp (e.g. gen regions, per row: start, end)\n#' @param at_least_one If TRUE no allowed merging errors in windows of size 1\n#' @param blockinfo_mode Structure of the groups in step I (default: 0 - Common haplos as major variants, 1- minimum number of groups)\n#' @param max_groups Maximum number of groups per window (adaptive window-size, default: 0 - use fixed window size)\n#' @export\n\n\nblockinfo_calculation <- function(dhm, window_sequence=NULL, window_size=20, merging_error=1, bp_map=NULL,\n                                  window_anchor_gens=NULL, at_least_one=TRUE, max_groups=0, blockinfo_mode=0,\n                                  c_dhm=NULL){\n\n  if(length(window_anchor_gens)>0 && length(window_sequence)==0 && length(bp_map)>0){\n    window_sequence <- matrix(0, ncol=2, nrow=nrow(window_anchor_gens)*2+1)\n    start <- 1\n    for(index in 1:nrow(window_anchor_gens)){\n      end <- sum(bp_map<window_anchor_gens[index,1])\n      window_sequence[index*2-1,] <- c(start, end)\n      end2 <- sum(bp_map<=window_anchor_gens[index,2])\n      window_sequence[index*2,] <- c(end+1, end2)\n      start <- end2+1\n    }\n    window_sequence[index*2+1,] <- c(start, length(bp_map))\n    removes <-(window_sequence[,1]>window_sequence[,2])*(1:nrow(window_sequence))\n    window_sequence <- window_sequence[-removes,]\n  }\n\n  if(max_groups==0 && length(window_sequence)==0){\n    window_sequence <- cbind(0:(nrow(dhm)/window_size-1)*window_size+1, 1:(nrow(dhm)/window_size)*window_size)\n  }\n  if(max_groups==0 && ncol(window_sequence)==2){\n    window_sequence <- cbind(window_sequence, window_sequence[,2]-window_sequence[,1]+1, window_sequence[,2]-window_sequence[,1]-merging_error+1)\n  }\n  if(max_groups==0 && ncol(window_sequence)==3){\n    window_sequence <- cbind(window_sequence[,1:2], window_sequence[,2]-window_sequence[,1]+1, window_sequence[,2]-window_sequence[,1]+1-window_sequence[,3])\n  }\n  if(max_groups==0 && at_least_one== TRUE && sum(window_sequence[,4]==0)>0){\n    window_sequence[window_sequence[,4]==0, 4] <- 1\n  }\n\n  cat(\"Start_blockinfo_calculation\\n\")\n  blockinfo <- list()\n  indi <- ncol(dhm)\n  if(max_groups==0){\n    ite <- nrow(window_sequence)\n  } else{\n    ite <- nrow(dhm)\n    window_sequence <- matrix(0, nrow=ite, ncol=4)\n    window_sequence[1,] <- c(1,2,1+merging_error,1)\n  }\n\n\n  last.block <- rep(1, indi)\n  nblocks.old <- 1\n  old.ac <- 1\n  if(max_groups==0){\n    for(index in 1:ite){\n\n      blockinfo[[index]] <- list()\n      if(ite<=25 || index%%round(ite/25.1)==0){\n        cat(\".\")\n      }\n      factor <- factorSNPs(c_dhm, window_sequence[index,1],\n                           window_sequence[index,2])\n      vers <- dhm[window_sequence[index,1]: window_sequence[index,2],\n                  attr(factor, \"where.to.find\"), drop=FALSE]\n\n      nblocks <- ncol(vers)\n      similarity <- colSumsEqualSNPs(vers)\n\n      if(blockinfo_mode==1){\n        # Similarity-Merging\n        skip <- rep(FALSE, nblocks)\n        nr.coding <- 1:nblocks\n        for(index3 in 1:nblocks){\n          if(skip[index3]==FALSE){\n            options <- similarity[index3,]\n            merges <- unique(c(0,(options>=(window_sequence[index,4])) * (1:nblocks)))[-1]\n            if(length(merges)>1){\n              options <- similarity[merges,]\n              merges <- unique(c(0,t(options>=(window_sequence[index,4])) * (1:nblocks)))[-1]\n            }\n            skip[merges] <- TRUE\n            nr.coding[merges] <- index3\n          }\n        }\n\n        current.block <- factor\n        for(switch in 1:nblocks){\n          if(nr.coding[switch]!=switch){\n            current.block[current.block==switch] <- nr.coding[switch]\n          }\n        }\n        hblocks <- numeric(nblocks)\n        for(count in 1:nblocks){\n          hblocks[count] <- sum(current.block==count)\n        }\n      } else{\n        current.block <- factor\n        hblocks <- attr(factor, \"counts\")\n        ordering <- sort(hblocks, decreasing=TRUE, index.return=TRUE)$ix\n\n        current <- 1\n        skip <- rep(FALSE, nblocks)\n        nr.coding <- 1:nblocks\n        for(index3 in ordering){\n          new_p <- ordering[which(similarity[ordering[1:current], index3]>=window_sequence[index,4])[1]]\n          if(new_p!=index3){\n            skip[index3] <- TRUE\n            nr.coding[index3] <- new_p\n            current.block[current.block==index3] <- nr.coding[new_p]\n            similarity[index3,] <- similarity[new_p,]\n            similarity[,index3] <- similarity[,new_p]\n            current.block[current.block==index3] <- new_p\n          }\n          current <- current+1\n\n\n        }\n\n        hblocks <- numeric(nblocks)\n        for(count in 1:nblocks){\n          hblocks[count] <- sum(current.block==count)\n        }\n      }\n\n\n      transition <- matrix(0, ncol=nblocks.old, nrow=nblocks)\n      for(new in 1:nblocks){\n        for(old in 1:nblocks.old){\n          transition[new,old] <- sum((current.block==new)*(last.block==old))\n        }\n      }\n      ac <- unique(nr.coding)\n      blockinfo[[index]][[1]] <- hblocks[ac]\n      blockinfo[[index]][[2]] <- similarity[ac,ac, drop=FALSE]\n      blockinfo[[index]][[3]] <- transition[ac,old.ac, drop=FALSE]\n\n      blockinfo[[index]][[4]] <- list()\n      for(listn in 1:length(ac)){\n        blockinfo[[index]][[4]][[listn]] <- vers[,nr.coding==ac[listn],drop=FALSE]\n      }\n      blockinfo[[index]][[5]] <- list()\n      for(listn in 1:length(ac)){\n        blockinfo[[index]][[5]][[listn]] <- which(current.block==ac[listn])\n      }\n\n      last.block <- current.block\n      nblocks.old <- nblocks\n      old.ac <- ac\n\n      pos <- numeric(length(vers))\n    }\n  } else{\n    activ_end <- 2\n    current_window <- 1\n    while(activ_end <= nrow(dhm)){\n      possiblock <- list()\n      if(ite<=25 || current_window%%round(ite/25.1)==0){\n        cat(\".\")\n      }\n\n\n      factor <- factorSNPs(c_dhm, window_sequence[current_window,1],\n                           window_sequence[current_window,2])\n      vers <- dhm[window_sequence[current_window,1]: window_sequence[current_window,2],\n                  attr(factor, \"where.to.find\"), drop=FALSE]\n\n      nblocks <- ncol(vers)\n      similarity <- colSumsEqualSNPs(vers)\n\n      if(blockinfo_mode==1){\n        skip <- rep(FALSE, nblocks)\n        nr.coding <- 1:nblocks\n        for(index3 in 1:nblocks){\n          if(skip[index3]==FALSE){\n            options <- similarity[index3,]\n            merges <- unique(c(0,(options>=(window_sequence[current_window,4])) * (1:nblocks)))[-1]\n            if(length(merges)>1){\n              options <- similarity[merges,]\n              merges <- unique(c(0,t(options>=(window_sequence[current_window,4])) * (1:nblocks)))[-1]\n            }\n            skip[merges] <- TRUE\n            nr.coding[merges] <- index3\n          }\n        }\n\n        current.block <- factor\n        for(switch in 1:nblocks){\n          if(nr.coding[switch]!=switch){\n            current.block[current.block==switch] <- nr.coding[switch]\n          }\n        }\n        hblocks <- numeric(nblocks)\n        for(count in 1:nblocks){\n          hblocks[count] <- sum(current.block==count)\n        }\n      } else{\n\n        current.block <- factor\n        hblocks <- attr(factor, \"counts\")\n        ordering <- sort(hblocks, decreasing=TRUE, index.return=TRUE)$ix\n\n        current <- 1\n        skip <- rep(FALSE, nblocks)\n        nr.coding <- 1:nblocks\n        for(index3 in ordering){\n          new_p <- ordering[which(similarity[ordering[1:current], index3]>=window_sequence[current_window,4])[1]]\n          if(new_p!=index3){\n            skip[index3] <- TRUE\n            nr.coding[index3] <- new_p\n            current.block[current.block==index3] <- nr.coding[new_p]\n            similarity[index3,] <- similarity[new_p,]\n            similarity[,index3] <- similarity[,new_p]\n            current.block[current.block==index3] <- new_p\n          }\n          current <- current+1\n\n\n        }\n\n        hblocks <- numeric(nblocks)\n        for(count in 1:nblocks){\n          hblocks[count] <- sum(current.block==count)\n        }\n      }\n\n\n      transition <- matrix(0, ncol=nblocks.old, nrow=nblocks)\n      for(new in 1:nblocks){\n        for(old in 1:nblocks.old){\n          transition[new,old] <- sum((current.block==new)*(last.block==old))\n        }\n      }\n      ac <- unique(nr.coding)\n      possiblock[[1]] <- hblocks[ac]\n      possiblock[[2]] <- similarity[ac,ac, drop=FALSE]\n      possiblock[[3]] <- transition[ac,old.ac, drop=FALSE]\n      possiblock[[4]] <- list()\n      for(listn in 1:length(ac)){\n        possiblock[[4]][[listn]] <- vers[,nr.coding==ac[listn], drop=FALSE]\n      }\n      possiblock[[5]] <- list()\n      for(listn in 1:length(ac)){\n        possiblock[[5]][[listn]] <- which(current.block==ac[listn])\n      }\n      if(activ_end==(nrow(dhm))){\n        blockinfo[[current_window]] <- possiblock\n        window_sequence <- window_sequence[1:current_window,]\n        activ_end <- activ_end +1\n      } else if(sum(hblocks>0)>max_groups){\n        blockinfo[[current_window]] <- possiblock.temp\n        last.block <- last.block.temp\n        nblocks.old <- nblocks.old.temp\n        old.ac <- old.ac.temp\n        window_sequence[current_window,] <- window_sequence[current_window,] + c(0,-1,-1,-1)\n        current_window <- current_window + 1\n        activ_end <- activ_end + floor(log(max_groups, base=2)) - 1\n        window_sequence[current_window, ] <- c(window_sequence[current_window-1, 2] +1 , activ_end, 0,0)\n        window_sequence[current_window, 3] <- diff(window_sequence[current_window, 1:2]) + 1\n        window_sequence[current_window, 4] <- window_sequence[current_window, 3] - merging_error\n      } else{\n        possiblock.temp <- possiblock\n        last.block.temp <- current.block\n        nblocks.old.temp <- nblocks\n        old.ac.temp <- ac\n        activ_end <- activ_end + 1\n        window_sequence[current_window, 2:4] <- window_sequence[current_window, 2:4] +1\n      }\n\n    }\n  }\n\n\n  for(index in 1:length(blockinfo)){\n    blockinfo[[index]][[6]] <- list()\n    for(index2 in 1:length(blockinfo[[index]][[4]])){\n      count <- numeric(ncol(blockinfo[[index]][[4]][[index2]]))\n      if(length(count)>1){\n        for(index3 in 1:length(count)){\n          count[index3] <- sum(dhm[window_sequence[index,1]:window_sequence[index,2], blockinfo[[index]][[5]][[index2]]] == blockinfo[[index]][[4]][[index2]][,index3])\n        }\n      }else{\n        count <- 1\n      }\n      blockinfo[[index]][[6]][[index2]] <- blockinfo[[index]][[4]][[index2]][,which.max(count)]\n\n    }\n  }\n  if(length(bp_map)==0){\n    bp_map <- rep(0, max(window_sequence[,2]))\n  }\n  for(index in 1:length(blockinfo)){\n    blockinfo[[index]][[7]] <- c(bp_map[window_sequence[index,1]], bp_map[window_sequence[index,2]])\n  }\n  if(length(bp_map)>0 && ncol(window_sequence)==4){\n    window_sequence <- cbind(window_sequence, bp_map[window_sequence[,1]], bp_map[window_sequence[,2]])\n  }\n\n  return(list(blockinfo, window_sequence))\n}\n\n\n",
    "created" : 1524223732887.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "122829719",
    "id" : "495B4C15",
    "lastKnownWriteTime" : 1524223744,
    "last_content_update" : 1524223744936,
    "path" : "C:/Users/tpook/Desktop/R-Stuff/HaploBlocker/R/blockinfo_calculation.R",
    "project_path" : "R/blockinfo_calculation.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "relative_order" : 74,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}