running <- 1
class_index <- numeric(length(class))
for(index2 in 1:length(class)){
dataset[index, class[[index2]]] <- running
if(length(class[[index2]])>0){
class_index[index2] <- running
running <- running + 1
}
}
if(consider_nonblock){
to_test <- which(dataset[index,]==0)
for(index2 in to_test){
temp1 <- colSums(data[window[1]:window[2], index2] == t(variants))
if(max(temp1)==ncol(variants)){
dataset[index,index2] <- class_index[which.max(temp1)]
}
}
}
consider_nonblock
to_test
dataset
dataset[index,]
to_test <- which(dataset[index,]==0)
data[window[1]:window[2], index2]
t(variants)
data <- as.matrix(data)
if(length(data)>0 && is.matrix(data)==FALSE){
data <- as.matrix(data)
}
if(length(blocklist)==0){
blocklist <- block_calculation(data)
}
n_indi <- indi_calc(blocklist)
se <- blocklist_startend(blocklist)
end_block  <- sort(unique(c(0,se[,1]-1, se[,2])))[-1]
start_block <- c(min(se), end_block[1:(length(end_block)-1)]+1)
if(non_haploblocker){
dhm <- as.matrix(data)
unique.dhm <- unique(as.vector(dhm))
fixcoding(unique.dhm)
c_dhm <- codeSNPs(dhm)
blockinfo <- blockinfo_calculation(dhm, window_sequence = cbind(start_block, end_block), merging_error = 0, c_dhm=c_dhm)
dataset <- block_dataset_construction(blockinfo[[1]],blocklist)
} else{
dataset <- matrix(0, nrow=length(start_block), ncol=n_indi)
for(index in 1:length(start_block)){
active_blocks <- which(((se[,1]<=start_block[index]) * (se[,2]>=end_block[index])==1))
window <- c(start_block[index], end_block[index])
variants <- matrix(NA, nrow=length(active_blocks), ncol=diff(window)+1)
for(index2 in 1:length(active_blocks)){
variants[index2,] <- blocklist[[active_blocks[[index2]]]][[7]]$snp[-blocklist[[active_blocks[[index2]]]][[2]]$snp +window[1]:window[2]+1]
}
variants <- unique(variants)
class <- list()
class_count <- numeric(nrow(variants))
for(index2 in 1:length(active_blocks)){
class_nr <- which.max(colSums(t(variants)==blocklist[[active_blocks[[index2]]]][[7]]$snp[-blocklist[[active_blocks[[index2]]]][[2]]$snp +window[1]:window[2]+1]))
if(length(class)<class_nr){
class[[class_nr]] <- blocklist[[active_blocks[[index2]]]][[6]]
} else{
class[[class_nr]] <- unique(c(class[[class_nr]],blocklist[[active_blocks[[index2]]]][[6]]))
}
}
for(index2 in 1:nrow(variants)){
if(length(class)>=index2){
class_count[index2] <- length( class[[index2]])
}
}
while(sum(duplicated(unlist(class))>0)){
full <- unlist(class)
full <- full[which(duplicated(full))]
candidates_remove <- NULL
for(index2 in 1:length(class)){
if(sum(class[[index2]]==full[1])){
candidates_remove <- c(candidates_remove, index2)
}
}
candidates_remove <- candidates_remove[-which.max(class_count[candidates_remove])]
for(index2 in candidates_remove){
class[[index2]] <- setdiff(class[[index2]], full)
}
for(index2 in 1:nrow(variants)){
if(length(class)>=index2){
class_count[index2] <- length( class[[index2]])
}
}
}
running <- 1
class_index <- numeric(length(class))
for(index2 in 1:length(class)){
dataset[index, class[[index2]]] <- running
if(length(class[[index2]])>0){
class_index[index2] <- running
running <- running + 1
}
}
if(consider_nonblock){
to_test <- which(dataset[index,]==0)
for(index2 in to_test){
temp1 <- colSums(data[window[1]:window[2], index2] == t(variants))
if(max(temp1)==ncol(variants)){
dataset[index,index2] <- class_index[which.max(temp1)]
}
}
}
}
}
new_data <- block_windowdataset(blocklist,consider_nonblock = TRUE)
library(HaploBlocker)
new_data <- block_windowdataset(blocklist,consider_nonblock = TRUE)
new_data <- block_windowdataset(blocklist, data= ex_maze, consider_nonblock = TRUE)
new_data[1:8,1:8]
new_data <- block_windowdataset(blocklist, data= ex_maze, non_haploblocker = TRUE)
new_data[1:8,1:8]
ex_maze[1:10,1:10]
colnames(ex_maze) <- paste0("Haplo ", 1:313)
rownames(ex_maze) <- paste0("SNP ", 1:9999)
colnames(ex_maze) <- paste0("Haplo ", 1:313)
ex_maze[1:10,1:10]
rownames(ex_maze) <- paste0("SNP ", 1:9999)
ex_maze[1:10,1:8]
blocklist
blocklist[[1]]
block_plot(blocklist)
block_plot(blocklist)
plot_block(blocklist)
blocklist_startend(blocklist)
blocklist_startend(blocklist)
library(HaploBlocker)
blocklist_startend(blocklist)
devtools::install_github("tpook92/MoBPS", subdir="pkg")
set.seed(7)
nindi <- 19
library(MoBPS) # MoBPS is available at https://github.com/tpook92/
# Generate a base-population with 50k SNPs, 3 Morgan genome,
# fully homozygous individuals,
# all plants are stored as male individuals (sex=0)
population <- creating.diploid(nindi=nindi, nsnp=50000, sex.quota = 0,
chromosome.length = 3, dataset="homorandom")
# Simulate matings between all founders
population <- breeding.diploid(population, breeding.size=c(nindi*(nindi-1)/2,0),
selection.size=c(nindi,0),
breeding.all.combination = TRUE,
mutation.rate=10^-4)
devtools::install_github("tpook92/MoBPS", subdir="pkg")
set.seed(7)
nindi <- 19
library(MoBPS) # MoBPS is available at https://github.com/tpook92/
# Generate a base-population with 50k SNPs, 3 Morgan genome,
# fully homozygous individuals,
# all plants are stored as male individuals (sex=0)
population <- creating.diploid(nindi=nindi, nsnp=50000, sex.quota = 0,
chromosome.length = 3, dataset="homorandom")
# Simulate matings between all founders
population <- breeding.diploid(population, breeding.size=c(nindi*(nindi-1)/2,0),
selection.size=c(nindi,0),
breeding.all.combination = TRUE,
mutation.rate=10^-4)
# Simulation of 4 generations of random mating of the prior generation
for(index in 1:4){
population <- breeding.diploid(population, breeding.size=c(nindi*(nindi-1)/2,0),
selection.size=c(nindi*(nindi-1)/2,0),
same.sex.activ = TRUE, same.sex.sex=0,
mutation.rate=10^-4)
}
# Simulation of 10 generations of self-fertilization
# Only one offspring per plant
for(index in 1:10){
population <- breeding.diploid(population, breeding.size=c(nindi*(nindi-1)/2,0),
selection.size=c(nindi*(nindi-1)/2,0),
selfing.mating=TRUE, selfing.sex=0,
max.offspring = 1, mutation.rate=10^-4)
}
# Derive haplotypes of last generation and founders
# Founders are double haploid (only one haplotype by plant needed)
haplos <- get.haplo(population, gen=16)
founderhaplo <- get.haplo(population, gen=1)[,1:nindi*2]
# Derivation of the haplotype library
library(HaploBlocker)
blockl <- block_calculation(haplos, target_coverage = 0.95)
# Extract points of recombination for final generation in MoBPS:
recombination <- get.recombi(population, gen=16)
get.recombi
# Extract points of recombination for final generation in MoBPS:
recombination <- get.recombi(population, gen=16)
# Extract points of recombination for final generation in MoBPS:
recombination <- get.recombi(population, database = cbind(16,1))
# Compare founder haplotypes to haplotype blocks:
start <- blockl[[1]][[2]]$snp
end <- blockl[[1]][[3]]$snp
concordance <- colMeans(founderhaplo[start:end,]==blockl[[1]][[7]]$snp)
concordance
se <- blocklist_startend(blockl)
mean(se[,2]-se[,1])
t <- coverage_test(blockl)
mean(t)
founder_info <- matrix(NA, nrow=length(blockl), ncol=6)
representation <- matrix(0, nrow=nrow(haplos), ncol=ncol(founderhaplo))
representation99 <- matrix(0, nrow=nrow(haplos), ncol=ncol(founderhaplo))
for(index in 1:length(blockl)){
start <- blockl[[index]][[2]]$snp
end <- blockl[[index]][[3]]$snp
concordance <- founderhaplo[start:end,]==blockl[[index]][[7]]$snp
overlap <- colSums(concordance) / (end-start+1)
founder_info[index, 1:2] <- c(which.max(overlap), max(overlap))
founder_info[index, 3:4] <- c(which.max(overlap[-founder_info[index,1]]), max(overlap[-founder_info[index,1]]))
if(founder_info[index,2]==1){
representation[start:end, founder_info[index,1]] <- representation[start:end,founder_info[index,1]] +1
}
if(founder_info[index,2]>=0.99){
representation99[start:end, founder_info[index,1]] <- representation99[start:end,founder_info[index,1]] +1
}
if(max(overlap)==1){
founder_info[index,5] <- which.max(overlap)[1]
}
if(max(overlap)>=0.99){
founder_info[index,6] <- which.max(overlap)[1]
}
}
mean(representation>0)
mean(representation99>0)
mean(founder_info[,2]>=1)
mean(founder_info[,2]>=0.99)
plot(founder_info[,2])
library(randomcoloR)
set.seed(7)
coloring <- distinctColorPalette(nindi)
{
png("C:/Users/pook/Desktop/Fig10.png", width=2250, height= 800, res=300)
par(mar=c(4.1,10.1,0.6,0.6))
firstn <- 5
sets <-  1
plot(-100000,0,ylim=c(0,firstn*length(sets)), xlim=c(0, max(start)), xlab="SNP", yaxt='n', ylab="")
axis(2, at=1:firstn-0.75, label=paste(c("est. founder: haplo "), 1:firstn), las=2)
axis(2, at=1:firstn-0.25, label=paste(c("real founder: haplo "), 1:firstn), las=2)
for(off in 1:firstn){
for(set in sets){
present <- NULL
for(index in 1:length(blockl)){
if(sum(blockl[[index]][[6]]==(off*2+set-length(sets)))){
present <- c(present, index)
}
}
start <- se[present,]
se_alt <- population$breeding[[16]][[1]][[off]][[set]] * 10000*5/3
founder_alt <- NULL
for(index in 1:length(population$breeding[[16]][[1]][[off]][[set+4]])){
founder_alt <- c(founder_alt,miraculix::decodeOrigins(population$breeding[[16]][[1]][[off]][[set+4]], row=index)[3])
}
for(index1 in 1:length(present)){
index <- present[index1]
polygon(c(se[index,1], se[index,2], se[index,2], se[index,1]), c(0.05,0.05,0.45,0.45)+off*length(sets)+set-length(sets)*2+1-(1*length(sets)==1),
col=coloring[founder_info[index,6]], lty=0)
}
for(index in 1:length(founder_alt)){
polygon(c(se_alt[index], se_alt[index+1], se_alt[index+1], se_alt[index]), c(0.55,0.55,0.95,0.95) + length(sets)*off +set-length(sets)*2+1-(1*length(sets)==1),
col=coloring[founder_alt[index]], lty=0)
}
}
}
dev.off()
png("C:/Users/pook/Desktop/Fig10_old.png", width=2250, height= 1000, res=300)
par(mar=c(4.1,10.1,1.1,1.1))
firstn <- 5
sets <-  1
plot(-100000,0,ylim=c(0,firstn*length(sets)), xlim=c(0, max(start)), xlab="SNP", yaxt='n', ylab="")
axis(2, at=1:firstn-0.75, label=paste(c("est. founder: haplo "), 1:firstn), las=2)
axis(2, at=1:firstn-0.25, label=paste(c("real founder: haplo "), 1:firstn), las=2)
for(off in 1:firstn){
for(set in sets){
present <- NULL
for(index in 1:length(blockl)){
if(sum(blockl[[index]][[6]]==(off*2+set-length(sets)))){
present <- c(present, index)
}
}
start <- se[present,]
se_alt <- population$breeding[[16]][[1]][[off]][[set]] * 10000*5/3
founder_alt <- NULL
for(index in 1:length(population$breeding[[16]][[1]][[off]][[set+4]])){
founder_alt <- c(founder_alt,miraculix::decodeOrigins(population$breeding[[16]][[1]][[off]][[set+4]], row=index)[3])
}
for(index1 in 1:length(present)){
index <- present[index1]
polygon(c(se[index,1], se[index,2], se[index,2], se[index,1]), c(0.05,0.05,0.45,0.45)+off*length(sets)+set-length(sets)*2+1-(1*length(sets)==1),
col=adjustcolor(founder_info[index,6],alpha.f=1), lty=0)
}
for(index in 1:length(founder_alt)){
polygon(c(se_alt[index], se_alt[index+1], se_alt[index+1], se_alt[index]), c(0.55,0.55,0.95,0.95) + length(sets)*off +set-length(sets)*2+1-(1*length(sets)==1),
col=adjustcolor(founder_alt[index],alpha.f=1), lty=0)
}
}
}
dev.off()
}
set.seed(7)
coloring <- distinctColorPalette(nindi)
{
png("C:/Users/pook/Desktop/Fig10.png", width=2250, height= 800, res=300)
par(mar=c(4.1,10.1,0.6,0.6))
firstn <- 5
sets <-  1
plot(-100000,0,ylim=c(0,firstn*length(sets)), xlim=c(0, max(start)), xlab="SNP", yaxt='n', ylab="")
axis(2, at=1:firstn-0.75, label=paste(c("est. founder: haplo "), 1:firstn), las=2)
axis(2, at=1:firstn-0.25, label=paste(c("real founder: haplo "), 1:firstn), las=2)
for(off in 1:firstn){
for(set in sets){
present <- NULL
for(index in 1:length(blockl)){
if(sum(blockl[[index]][[6]]==(off*2+set-length(sets)))){
present <- c(present, index)
}
}
start <- se[present,]
se_alt <- population$breeding[[16]][[1]][[off]][[set]] * 10000*5/3
founder_alt <- NULL
for(index in 1:length(population$breeding[[16]][[1]][[off]][[set+4]])){
founder_alt <- c(founder_alt,miraculix::decodeOrigins(population$breeding[[16]][[1]][[off]][[set+4]], row=index)[3])
}
for(index1 in 1:length(present)){
index <- present[index1]
polygon(c(se[index,1], se[index,2], se[index,2], se[index,1]), c(0.05,0.05,0.45,0.45)+off*length(sets)+set-length(sets)*2+1-(1*length(sets)==1),
col=coloring[founder_info[index,6]], lty=0)
}
for(index in 1:length(founder_alt)){
polygon(c(se_alt[index], se_alt[index+1], se_alt[index+1], se_alt[index]), c(0.55,0.55,0.95,0.95) + length(sets)*off +set-length(sets)*2+1-(1*length(sets)==1),
col=coloring[founder_alt[index]], lty=0)
}
}
}
dev.off()
png("C:/Users/pook/Desktop/Fig10_old.png", width=2250, height= 1000, res=300)
par(mar=c(4.1,10.1,1.1,1.1))
firstn <- 5
sets <-  1
plot(-100000,0,ylim=c(0,firstn*length(sets)), xlim=c(0, max(start)), xlab="SNP", yaxt='n', ylab="")
axis(2, at=1:firstn-0.75, label=paste(c("est. founder: haplo "), 1:firstn), las=2)
axis(2, at=1:firstn-0.25, label=paste(c("real founder: haplo "), 1:firstn), las=2)
for(off in 1:firstn){
for(set in sets){
present <- NULL
for(index in 1:length(blockl)){
if(sum(blockl[[index]][[6]]==(off*2+set-length(sets)))){
present <- c(present, index)
}
}
start <- se[present,]
se_alt <- population$breeding[[16]][[1]][[off]][[set]] * 10000*5/3
founder_alt <- NULL
for(index in 1:length(population$breeding[[16]][[1]][[off]][[set+4]])){
founder_alt <- c(founder_alt,miraculix::decodeOrigins(population$breeding[[16]][[1]][[off]][[set+4]], row=index)[3])
}
for(index1 in 1:length(present)){
index <- present[index1]
polygon(c(se[index,1], se[index,2], se[index,2], se[index,1]), c(0.05,0.05,0.45,0.45)+off*length(sets)+set-length(sets)*2+1-(1*length(sets)==1),
col=adjustcolor(founder_info[index,6],alpha.f=1), lty=0)
}
for(index in 1:length(founder_alt)){
polygon(c(se_alt[index], se_alt[index+1], se_alt[index+1], se_alt[index]), c(0.55,0.55,0.95,0.95) + length(sets)*off +set-length(sets)*2+1-(1*length(sets)==1),
col=adjustcolor(founder_alt[index],alpha.f=1), lty=0)
}
}
}
dev.off()
}
library(HaploBlocker)
setwd("C:/Users/pook/Desktop/")
train_merge <- NULL
test_merge <- NULL
for(index in 1:20){
load(paste0("Block_GP_24_04_19/file",index,".RData"))
train_merge <- cbind(train_merge, training_cor)
test_merge <- cbind(test_merge, test_cor)
}
par(mar=c(4.1,4.1,0.6,0.6))
boxplot(t(test_merge), col=c("red", "brown", "blue"), xaxt="n")
pheno <- as.matrix(read.table("Genetic_Datasets/MAZE_BLUEs_acrossLocations_DHperse2017_v1.csv", sep=";"))[1,-1]
pheno[5] <- "PH_V4"
pheno[6] <- "PH_V6"
axis(1, at=seq(2,27, by=3), label=as.character(pheno))
legend("topleft", c("full SNP-dataset", "pruned SNP-Dataset", "Block-dataset"), fill=c("red", "brown", "blue"))
dev.off()
par(mar=c(4.1,4.1,0.6,0.6))
boxplot(t(test_merge), col=c("red", "brown", "blue"), xaxt="n")
?boxplot
boxplot(t(test_merge), col=c("red", "brown", "blue"), xaxt="n", at=1:27)
boxplot(t(test_merge), col=c("red", "brown", "blue"), xaxt="n", at=c(1:26,28))
par(mar=c(4.1,4.1,0.6,0.6))
boxplot(t(test_merge), col=c("red", "brown", "blue"), xaxt="n", at=1:27+rep(1:9,each=1))
1:27+rep(1:9,each=1)
boxplot(t(test_merge), col=c("red", "brown", "blue"), xaxt="n", at=1:27+rep(1:9,each=3))
pheno <- as.matrix(read.table("Genetic_Datasets/MAZE_BLUEs_acrossLocations_DHperse2017_v1.csv", sep=";"))[1,-1]
pheno[5] <- "PH_V4"
1:27+rep(1:9,each=3)
par(mar=c(4.1,4.1,0.6,0.6))
boxplot(t(test_merge), col=c("red", "brown", "blue"), xaxt="n", at=1:27+rep(1:9,each=3))
pheno <- as.matrix(read.table("Genetic_Datasets/MAZE_BLUEs_acrossLocations_DHperse2017_v1.csv", sep=";"))[1,-1]
pheno[5] <- "PH_V4"
pheno[6] <- "PH_V6"
axis(1, at=seq(2,36, by=4), label=as.character(pheno))
legend("topleft", c("full SNP-dataset", "pruned SNP-Dataset", "Block-dataset"), fill=c("red", "brown", "blue"))
png(file="C:/Users/pook/Desktop/GP_comparison_block.png", width=3250, height= 1160, res=300)
par(mar=c(4.1,4.1,0.6,0.6))
boxplot(t(test_merge), col=c("red", "brown", "blue"), xaxt="n", at=1:27+rep(1:9,each=3))
pheno <- as.matrix(read.table("Genetic_Datasets/MAZE_BLUEs_acrossLocations_DHperse2017_v1.csv", sep=";"))[1,-1]
pheno[5] <- "PH_V4"
pheno[6] <- "PH_V6"
axis(1, at=seq(2,36, by=4), label=as.character(pheno))
legend("topleft", c("full SNP-dataset", "pruned SNP-Dataset", "Block-dataset"), fill=c("red", "brown", "blue"))
dev.off()
setwd("C:/Users/pook/Desktop/")
train_merge <- NULL
test_merge <- NULL
for(index in 1:20){
load(paste0("Block_GP_24_04_19/file",index,"_PE.RData"))
train_merge <- cbind(train_merge, training_cor)
test_merge <- cbind(test_merge, test_cor)
}
legend("topleft", c("full SNP-dataset", "pruned SNP-Dataset", "Block-dataset"), fill=c("red", "darkgreen", "blue"))
setwd("C:/Users/pook/Desktop/")
train_merge <- NULL
test_merge <- NULL
for(index in 1:20){
load(paste0("Block_GP_24_04_19/file",index,".RData"))
train_merge <- cbind(train_merge, training_cor)
test_merge <- cbind(test_merge, test_cor)
}
png(file="C:/Users/pook/Desktop/GP_comparison_block.png", width=3250, height= 1160, res=300)
par(mar=c(4.1,4.1,0.6,0.6))
boxplot(t(test_merge), col=c("red", "darkgreen", "blue"), xaxt="n", at=1:27+rep(1:9,each=3))
pheno <- as.matrix(read.table("Genetic_Datasets/MAZE_BLUEs_acrossLocations_DHperse2017_v1.csv", sep=";"))[1,-1]
pheno[5] <- "PH_V4"
pheno[6] <- "PH_V6"
axis(1, at=seq(2,36, by=4), label=as.character(pheno))
legend("topleft", c("full SNP-dataset", "pruned SNP-Dataset", "Block-dataset"), fill=c("red", "darkgreen", "blue"))
dev.off()
setwd("C:/Users/pook/Desktop/")
train_merge <- NULL
test_merge <- NULL
for(index in 1:20){
load(paste0("Block_GP_24_04_19/file",index,"_PE.RData"))
train_merge <- cbind(train_merge, training_cor)
test_merge <- cbind(test_merge, test_cor)
}
png(file="C:/Users/pook/Desktop/GP_comparison_block_PE.png", width=3250, height= 1160, res=300)
par(mar=c(4.1,4.1,0.6,0.6))
boxplot(t(test_merge), col=c("red", "darkgreen", "blue"), xaxt="n", at=1:27+rep(1:9,each=3))
pheno <- as.matrix(read.table("Genetic_Datasets/MAZE_BLUEs_acrossLocations_DHperse2017_v1.csv", sep=";"))[1,-1]
pheno[5] <- "PH_V4"
pheno[6] <- "PH_V6"
axis(1, at=seq(2,36, by=4), label=as.character(pheno))
legend("topleft", c("full SNP-dataset", "pruned SNP-Dataset", "Block-dataset"), fill=c("red", "darkgreen", "blue"))
dev.off()
train_merge <- NULL
test_merge <- NULL
for(index in 1:50){
load(paste0("Block_GP_24_04_19/file",index,"_weighted.RData"))
train_merge <- cbind(train_merge, training_cor)
test_merge <- cbind(test_merge, test_cor)
}
par(mar=c(4.1,4.1,0.6,0.6))
plot(seq(-0.5,1.5,by=0.1), rowMeans(test_merge)[c(20,20:1)], ylim=c(min(rowMeans(test_merge)), max(rowMeans(test_merge))),
type="l", xlab="s", ylab="avg. prediction accuracy")
take <- which.max(rowMeans(test_merge)[c(20,20:1)])
points(seq(-0.5,1.5,by=0.1)[take], rowMeans(test_merge)[c(20,20:1)][take], col="red")
for(t in 1:8){
lines(seq(-0.5,1.5,by=0.1), rowMeans(test_merge)[20:0+t*21])
take <- which.max(rowMeans(test_merge)[20:0+t*21])
points(seq(-0.5,1.5,by=0.1)[take], rowMeans(test_merge)[20:0+t*21][take], col="red")
}
dev.off()
setwd("C:/Users/pook/Desktop/")
train_merge <- NULL
test_merge <- NULL
for(index in 1:50){
load(paste0("Block_GP_24_04_19/file",index,"_weighted.RData"))
train_merge <- cbind(train_merge, training_cor)
test_merge <- cbind(test_merge, test_cor)
}
png(file="C:/Users/pook/Desktop/GP_weighting_block.png", width=2250, height= 1160, res=300)
par(mar=c(4.1,4.1,0.6,0.6))
plot(seq(-0.5,1.5,by=0.1), rowMeans(test_merge)[c(20,20:1)], ylim=c(min(rowMeans(test_merge)), max(rowMeans(test_merge))),
type="l", xlab="s", ylab="avg. prediction accuracy")
take <- which.max(rowMeans(test_merge)[c(20,20:1)])
points(seq(-0.5,1.5,by=0.1)[take], rowMeans(test_merge)[c(20,20:1)][take], col="red")
for(t in 1:8){
lines(seq(-0.5,1.5,by=0.1), rowMeans(test_merge)[20:0+t*21])
take <- which.max(rowMeans(test_merge)[20:0+t*21])
points(seq(-0.5,1.5,by=0.1)[take], rowMeans(test_merge)[20:0+t*21][take], col="red")
}
dev.off()
setwd("C:/Users/pook/Desktop/")
train_merge <- NULL
test_merge <- NULL
for(index in 1:50){
load(paste0("Block_GP_24_04_19/file",index,"_weighted_PE.RData"))
train_merge <- cbind(train_merge, training_cor)
test_merge <- cbind(test_merge, test_cor)
}
png(file="C:/Users/pook/Desktop/GP_weighting_PE_block.png", width=2250, height= 1160, res=300)
par(mar=c(4.1,4.1,0.6,0.6))
plot(seq(-0.5,1.5,by=0.1), rowMeans(test_merge)[c(20,20:1)], ylim=c(min(rowMeans(test_merge)), max(rowMeans(test_merge))),
type="l", xlab="s", ylab="avg. prediction accuracy")
take <- which.max(rowMeans(test_merge)[c(20,20:1)])
points(seq(-0.5,1.5,by=0.1)[take], rowMeans(test_merge)[c(20,20:1)][take], col="red")
for(t in 1:8){
lines(seq(-0.5,1.5,by=0.1), rowMeans(test_merge)[20:0+t*21])
take <- which.max(rowMeans(test_merge)[20:0+t*21])
points(seq(-0.5,1.5,by=0.1)[take], rowMeans(test_merge)[20:0+t*21][take], col="red")
}
dev.off()
library(HaploBlocker)
