multi_window_mode=FALSE;
adaptive_mode=FALSE;
developer_mode=FALSE;
double_share=1;
early_remove=FALSE;
node_min_early=NULL;
min_reduction_cross=-Inf;
min_reduction_neglet=-Inf;
parallel_window=Inf;
window_overlap=0;
window_cores=1;
window_sequence=NULL; window_size=20; merging_error=0; node_min=5; gap=10;
min_share=0.975; off_lines=2; min_similarity=0.99; merge_closeblock=FALSE;
max_diff_l=1; max_diff_i=1; min_majorblock=5000; bp_map=NULL; window_anchor_gens=NULL;
consider_nodes=TRUE; consider_edge=TRUE; edge_min=5; subgroups=NULL; min_per_subgroup=0; subgroup_exception=0;
consider_all=TRUE; save_allblock=TRUE; block_extending=TRUE;
max_extending_diff=1; extending_ratio=20; min_majorblock_steps=4;
snp_extending=TRUE; max_extending_diff_snp=0; extending_ratio_snp=Inf;  major_snp_calculation=TRUE;
off_node_addition=FALSE; off_node_minimum_blocklength=10; off_node_minimum_blocksize=5;
raster=5; at_least_one=TRUE;
prefilter=FALSE; maf=0.00; equal_remove=FALSE;
big_output=FALSE; blockinfo_mode=0; c_dhm_mode=TRUE;
intersect_func=TRUE; fast_compiler=TRUE;
max_groups=0; recoding=FALSE; recoding_notneeded=FALSE;
consider_multi=FALSE; multi_min=5; blockinfo_mode_na=FALSE;
actual_snp_weight = 5; na_snp_weight=2; na_seq_weight=0;
weighting_length=1; weighting_size=1;
recalculate_biggest=TRUE;
target_coverage=NULL;
max_iteration=10;
min_step_size=25;
target_stop=0.001;
multi_window_mode=FALSE;
adaptive_mode=FALSE;
developer_mode=FALSE;
double_share=1;
early_remove=FALSE;
node_min_early=NULL;
min_reduction_cross=-Inf;
min_reduction_neglet=-Inf;
parallel_window=Inf;
window_overlap=0;
window_cores=1;
load("C:/Users/pook/Desktop/Genetic_Datasets/Batch3_KEPE/KE_DH_chromo10.RData")
## Just copy from HP to derivte example window cluster
library(HaploBlocker)
library(RandomFieldsUtils)
dhm <- data
min_share <- 1
consider_all <- FALSE
min_similarity <- 1
# No window/snp-extensions
{
window_sequence_list <- list()
if(length(window_sequence)!=ncluster){
for(index in 1:ncluster){
window_sequence_list[[index]] <- window_sequence
}
} else{
window_sequence_list <- window_sequence
}
window_sequence_list[[ncluster+1]] <- "placeholder"
if(intersect_func){
intersect_func <- HaploBlocker::intersect
} else{
intersect_func <- base::intersect
}
if(is.data.frame(dhm)){
dhm <- as.matrix(dhm)
}
if(sum(is.na(dhm))>0){
dhm[is.na(dhm)] <- 9
}
if(prefilter==TRUE){
dhm <- dataset_filter(dhm, maf, equal_remove)
}
if(recoding==TRUE){
if(recoding_notneeded==TRUE){
recoding <- TRUE
} else{
for(index in 1:nrow(dhm)){
check1 <- dhm[index,]==dhm[index,1]
dhm[index, check1] <- "A"
dhm[index, -(check1)*1:indi] <- "C"
}
}
}
# Martins Erweiterung
unique.dhm <- unique(as.vector(dhm))
fixcoding(unique.dhm)
c_dhm <- codeSNPs(dhm)
blockinfo <- list()
data <- list()
dataset <- list()
partial_blocklist <- list()
nwindow <- rep(0, ncluster)
for(index in 1:ncluster){
if(blockinfo_mode_na){
blockinfo_out <- blockinfo_calculation_na(dhm, window_sequence= window_sequence_list[[index]], window_anchor_gens = window_anchor_gens, blockinfo_mode=blockinfo_mode,
window_size = window_size[index], merging_error = merging_error[index], bp_map = bp_map, at_least_one=at_least_one,
actual_snp_weight=actual_snp_weight, na_snp_weight=na_snp_weight, na_seq_weight= na_seq_weight)
} else{
blockinfo_out <- blockinfo_calculation(dhm, window_sequence= window_sequence_list[[index]], window_anchor_gens = window_anchor_gens, blockinfo_mode=blockinfo_mode,
window_size = window_size[index], merging_error = merging_error[index], bp_map = bp_map, at_least_one=at_least_one,
c_dhm=c_dhm, max_groups=max_groups)
}
blockinfo[[index]] <- blockinfo_out[[1]]
window_sequence_list[[index]] <- blockinfo_out[[2]]
if(max_groups>0){
cat(paste("Generated:", nrow(window_sequence_list[[index]]), "windows\n"))
cat(paste("With size: Max", max(window_sequence_list[[index]][,3]), "Min", min(window_sequence_list[[index]][,3]), "Avg", round(mean(window_sequence_list[[index]][,3])*100)/100),"\n")
}
data[[index]] <- nodes_calculation(blockinfo[[index]], window_sequence_list[[index]])
data[[index]] <- simple_merge(data[[index]], intersect_func=intersect_func)
data[[index]] <- calculate_transition(data[[index]], intersect_func=intersect_func)
}
}
length(data[[1]])
indi
nwindow[index]
data[[index]] <- simple_merge_prob(data[[index]], indi, nwindow[index])
length(data[[1]])
window_sequence=NULL; window_size=20; merging_error=0; node_min=5; gap=10;
min_share=0.975; off_lines=2; min_similarity=0.99; merge_closeblock=FALSE;
max_diff_l=1; max_diff_i=1; min_majorblock=5000; bp_map=NULL; window_anchor_gens=NULL;
consider_nodes=TRUE; consider_edge=TRUE; edge_min=5; subgroups=NULL; min_per_subgroup=0; subgroup_exception=0;
consider_all=TRUE; save_allblock=TRUE; block_extending=TRUE;
max_extending_diff=1; extending_ratio=20; min_majorblock_steps=4;
snp_extending=TRUE; max_extending_diff_snp=0; extending_ratio_snp=Inf;  major_snp_calculation=TRUE;
off_node_addition=FALSE; off_node_minimum_blocklength=10; off_node_minimum_blocksize=5;
raster=5; at_least_one=TRUE;
prefilter=FALSE; maf=0.00; equal_remove=FALSE;
big_output=FALSE; blockinfo_mode=0; c_dhm_mode=TRUE;
intersect_func=TRUE; fast_compiler=TRUE;
max_groups=0; recoding=FALSE; recoding_notneeded=FALSE;
consider_multi=FALSE; multi_min=5; blockinfo_mode_na=FALSE;
actual_snp_weight = 5; na_snp_weight=2; na_seq_weight=0;
weighting_length=1; weighting_size=1;
recalculate_biggest=TRUE;
target_coverage=NULL;
max_iteration=10;
min_step_size=25;
target_stop=0.001;
multi_window_mode=FALSE;
adaptive_mode=FALSE;
developer_mode=FALSE;
double_share=1;
early_remove=FALSE;
node_min_early=NULL;
min_reduction_cross=-Inf;
min_reduction_neglet=-Inf;
parallel_window=Inf;
window_overlap=0;
window_cores=1;
load("C:/Users/pook/Desktop/Genetic_Datasets/Batch3_KEPE/KE_DH_chromo10.RData")
## Just copy from HP to derivte example window cluster
library(HaploBlocker)
library(RandomFieldsUtils)
dhm <- data
min_share <- 1
consider_all <- FALSE
min_similarity <- 1
# No window/snp-extensions
{
window_sequence_list <- list()
if(length(window_sequence)!=ncluster){
for(index in 1:ncluster){
window_sequence_list[[index]] <- window_sequence
}
} else{
window_sequence_list <- window_sequence
}
window_sequence_list[[ncluster+1]] <- "placeholder"
if(intersect_func){
intersect_func <- HaploBlocker::intersect
} else{
intersect_func <- base::intersect
}
if(is.data.frame(dhm)){
dhm <- as.matrix(dhm)
}
if(sum(is.na(dhm))>0){
dhm[is.na(dhm)] <- 9
}
if(prefilter==TRUE){
dhm <- dataset_filter(dhm, maf, equal_remove)
}
if(recoding==TRUE){
if(recoding_notneeded==TRUE){
recoding <- TRUE
} else{
for(index in 1:nrow(dhm)){
check1 <- dhm[index,]==dhm[index,1]
dhm[index, check1] <- "A"
dhm[index, -(check1)*1:indi] <- "C"
}
}
}
# Martins Erweiterung
unique.dhm <- unique(as.vector(dhm))
fixcoding(unique.dhm)
c_dhm <- codeSNPs(dhm)
blockinfo <- list()
data <- list()
dataset <- list()
partial_blocklist <- list()
nwindow <- rep(0, ncluster)
for(index in 1:ncluster){
if(blockinfo_mode_na){
blockinfo_out <- blockinfo_calculation_na(dhm, window_sequence= window_sequence_list[[index]], window_anchor_gens = window_anchor_gens, blockinfo_mode=blockinfo_mode,
window_size = window_size[index], merging_error = merging_error[index], bp_map = bp_map, at_least_one=at_least_one,
actual_snp_weight=actual_snp_weight, na_snp_weight=na_snp_weight, na_seq_weight= na_seq_weight)
} else{
blockinfo_out <- blockinfo_calculation(dhm, window_sequence= window_sequence_list[[index]], window_anchor_gens = window_anchor_gens, blockinfo_mode=blockinfo_mode,
window_size = window_size[index], merging_error = merging_error[index], bp_map = bp_map, at_least_one=at_least_one,
c_dhm=c_dhm, max_groups=max_groups)
}
blockinfo[[index]] <- blockinfo_out[[1]]
window_sequence_list[[index]] <- blockinfo_out[[2]]
if(max_groups>0){
cat(paste("Generated:", nrow(window_sequence_list[[index]]), "windows\n"))
cat(paste("With size: Max", max(window_sequence_list[[index]][,3]), "Min", min(window_sequence_list[[index]][,3]), "Avg", round(mean(window_sequence_list[[index]][,3])*100)/100),"\n")
}
data[[index]] <- nodes_calculation(blockinfo[[index]], window_sequence_list[[index]])
}}
length(data[[1]])
data[[index]] <- nodes_calculation(blockinfo[[index]], window_sequence_list[[index]])
data[[index]] <- simple_merge(data[[index]], intersect_func=intersect_func)
data[[index]] <- calculate_transition(data[[index]], intersect_func=intersect_func)
data[[index]][[1]]
window_sequence=NULL; window_size=20; merging_error=0; node_min=5; gap=10;
min_share=0.975; off_lines=2; min_similarity=0.99; merge_closeblock=FALSE;
max_diff_l=1; max_diff_i=1; min_majorblock=5000; bp_map=NULL; window_anchor_gens=NULL;
consider_nodes=TRUE; consider_edge=TRUE; edge_min=5; subgroups=NULL; min_per_subgroup=0; subgroup_exception=0;
consider_all=TRUE; save_allblock=TRUE; block_extending=TRUE;
max_extending_diff=1; extending_ratio=20; min_majorblock_steps=4;
snp_extending=TRUE; max_extending_diff_snp=0; extending_ratio_snp=Inf;  major_snp_calculation=TRUE;
off_node_addition=FALSE; off_node_minimum_blocklength=10; off_node_minimum_blocksize=5;
raster=5; at_least_one=TRUE;
prefilter=FALSE; maf=0.00; equal_remove=FALSE;
big_output=FALSE; blockinfo_mode=0; c_dhm_mode=TRUE;
intersect_func=TRUE; fast_compiler=TRUE;
max_groups=0; recoding=FALSE; recoding_notneeded=FALSE;
consider_multi=FALSE; multi_min=5; blockinfo_mode_na=FALSE;
actual_snp_weight = 5; na_snp_weight=2; na_seq_weight=0;
weighting_length=1; weighting_size=1;
recalculate_biggest=TRUE;
target_coverage=NULL;
max_iteration=10;
min_step_size=25;
target_stop=0.001;
multi_window_mode=FALSE;
adaptive_mode=FALSE;
developer_mode=FALSE;
double_share=1;
early_remove=FALSE;
node_min_early=NULL;
min_reduction_cross=-Inf;
min_reduction_neglet=-Inf;
parallel_window=Inf;
window_overlap=0;
window_cores=1;
load("C:/Users/pook/Desktop/Genetic_Datasets/Batch3_KEPE/KE_DH_chromo10.RData")
## Just copy from HP to derivte example window cluster
library(HaploBlocker)
library(RandomFieldsUtils)
dhm <- data
min_share <- 1
consider_all <- FALSE
min_similarity <- 1
# No window/snp-extensions
{
window_sequence_list <- list()
if(length(window_sequence)!=ncluster){
for(index in 1:ncluster){
window_sequence_list[[index]] <- window_sequence
}
} else{
window_sequence_list <- window_sequence
}
window_sequence_list[[ncluster+1]] <- "placeholder"
if(intersect_func){
intersect_func <- HaploBlocker::intersect
} else{
intersect_func <- base::intersect
}
if(is.data.frame(dhm)){
dhm <- as.matrix(dhm)
}
if(sum(is.na(dhm))>0){
dhm[is.na(dhm)] <- 9
}
if(prefilter==TRUE){
dhm <- dataset_filter(dhm, maf, equal_remove)
}
if(recoding==TRUE){
if(recoding_notneeded==TRUE){
recoding <- TRUE
} else{
for(index in 1:nrow(dhm)){
check1 <- dhm[index,]==dhm[index,1]
dhm[index, check1] <- "A"
dhm[index, -(check1)*1:indi] <- "C"
}
}
}
# Martins Erweiterung
unique.dhm <- unique(as.vector(dhm))
fixcoding(unique.dhm)
c_dhm <- codeSNPs(dhm)
blockinfo <- list()
data <- list()
dataset <- list()
partial_blocklist <- list()
nwindow <- rep(0, ncluster)
for(index in 1:ncluster){
if(blockinfo_mode_na){
blockinfo_out <- blockinfo_calculation_na(dhm, window_sequence= window_sequence_list[[index]], window_anchor_gens = window_anchor_gens, blockinfo_mode=blockinfo_mode,
window_size = window_size[index], merging_error = merging_error[index], bp_map = bp_map, at_least_one=at_least_one,
actual_snp_weight=actual_snp_weight, na_snp_weight=na_snp_weight, na_seq_weight= na_seq_weight)
} else{
blockinfo_out <- blockinfo_calculation(dhm, window_sequence= window_sequence_list[[index]], window_anchor_gens = window_anchor_gens, blockinfo_mode=blockinfo_mode,
window_size = window_size[index], merging_error = merging_error[index], bp_map = bp_map, at_least_one=at_least_one,
c_dhm=c_dhm, max_groups=max_groups)
}
blockinfo[[index]] <- blockinfo_out[[1]]
window_sequence_list[[index]] <- blockinfo_out[[2]]
if(max_groups>0){
cat(paste("Generated:", nrow(window_sequence_list[[index]]), "windows\n"))
cat(paste("With size: Max", max(window_sequence_list[[index]][,3]), "Min", min(window_sequence_list[[index]][,3]), "Avg", round(mean(window_sequence_list[[index]][,3])*100)/100),"\n")
}
data[[index]] <- nodes_calculation(blockinfo[[index]], window_sequence_list[[index]])
data[[index]] <- simple_merge(data[[index]], intersect_func=intersect_func)
}}
length(data[[1]])
gap
node_min_early
intersect_func
tz <- ignore_small_nodes(data[[index]], indi, nwindow[index], node_min_early, gap, intersect_func=intersect_func)
index
length(data[[1]])
indi
indi <- 501
node_min
gap
z <- ignore_small_nodes(data[[index]], indi, nwindow[index], node_min, gap, intersect_func=intersect_func)
length(data)
length(data[[1]])
nwindow
window_sequence=NULL; window_size=20; merging_error=0; node_min=5; gap=10;
min_share=0.975; off_lines=2; min_similarity=0.99; merge_closeblock=FALSE;
max_diff_l=1; max_diff_i=1; min_majorblock=5000; bp_map=NULL; window_anchor_gens=NULL;
consider_nodes=TRUE; consider_edge=TRUE; edge_min=5; subgroups=NULL; min_per_subgroup=0; subgroup_exception=0;
consider_all=TRUE; save_allblock=TRUE; block_extending=TRUE;
max_extending_diff=1; extending_ratio=20; min_majorblock_steps=4;
snp_extending=TRUE; max_extending_diff_snp=0; extending_ratio_snp=Inf;  major_snp_calculation=TRUE;
off_node_addition=FALSE; off_node_minimum_blocklength=10; off_node_minimum_blocksize=5;
raster=5; at_least_one=TRUE;
prefilter=FALSE; maf=0.00; equal_remove=FALSE;
big_output=FALSE; blockinfo_mode=0; c_dhm_mode=TRUE;
intersect_func=TRUE; fast_compiler=TRUE;
max_groups=0; recoding=FALSE; recoding_notneeded=FALSE;
consider_multi=FALSE; multi_min=5; blockinfo_mode_na=FALSE;
actual_snp_weight = 5; na_snp_weight=2; na_seq_weight=0;
weighting_length=1; weighting_size=1;
recalculate_biggest=TRUE;
target_coverage=NULL;
max_iteration=10;
min_step_size=25;
target_stop=0.001;
multi_window_mode=FALSE;
adaptive_mode=FALSE;
developer_mode=FALSE;
double_share=1;
early_remove=FALSE;
node_min_early=NULL;
min_reduction_cross=-Inf;
min_reduction_neglet=-Inf;
parallel_window=Inf;
window_overlap=0;
window_cores=1;
load("C:/Users/pook/Desktop/Genetic_Datasets/Batch3_KEPE/KE_DH_chromo10.RData")
## Just copy from HP to derivte example window cluster
library(HaploBlocker)
library(RandomFieldsUtils)
dhm <- data
min_share <- 1
consider_all <- FALSE
min_similarity <- 1
# No window/snp-extensions
{
window_sequence_list <- list()
if(length(window_sequence)!=ncluster){
for(index in 1:ncluster){
window_sequence_list[[index]] <- window_sequence
}
} else{
window_sequence_list <- window_sequence
}
window_sequence_list[[ncluster+1]] <- "placeholder"
if(intersect_func){
intersect_func <- HaploBlocker::intersect
} else{
intersect_func <- base::intersect
}
if(is.data.frame(dhm)){
dhm <- as.matrix(dhm)
}
if(sum(is.na(dhm))>0){
dhm[is.na(dhm)] <- 9
}
if(prefilter==TRUE){
dhm <- dataset_filter(dhm, maf, equal_remove)
}
if(recoding==TRUE){
if(recoding_notneeded==TRUE){
recoding <- TRUE
} else{
for(index in 1:nrow(dhm)){
check1 <- dhm[index,]==dhm[index,1]
dhm[index, check1] <- "A"
dhm[index, -(check1)*1:indi] <- "C"
}
}
}
# Martins Erweiterung
unique.dhm <- unique(as.vector(dhm))
fixcoding(unique.dhm)
c_dhm <- codeSNPs(dhm)
blockinfo <- list()
data <- list()
dataset <- list()
partial_blocklist <- list()
nwindow <- rep(0, ncluster)
for(index in 1:ncluster){
if(blockinfo_mode_na){
blockinfo_out <- blockinfo_calculation_na(dhm, window_sequence= window_sequence_list[[index]], window_anchor_gens = window_anchor_gens, blockinfo_mode=blockinfo_mode,
window_size = window_size[index], merging_error = merging_error[index], bp_map = bp_map, at_least_one=at_least_one,
actual_snp_weight=actual_snp_weight, na_snp_weight=na_snp_weight, na_seq_weight= na_seq_weight)
} else{
blockinfo_out <- blockinfo_calculation(dhm, window_sequence= window_sequence_list[[index]], window_anchor_gens = window_anchor_gens, blockinfo_mode=blockinfo_mode,
window_size = window_size[index], merging_error = merging_error[index], bp_map = bp_map, at_least_one=at_least_one,
c_dhm=c_dhm, max_groups=max_groups)
}
blockinfo[[index]] <- blockinfo_out[[1]]
window_sequence_list[[index]] <- blockinfo_out[[2]]
if(max_groups>0){
cat(paste("Generated:", nrow(window_sequence_list[[index]]), "windows\n"))
cat(paste("With size: Max", max(window_sequence_list[[index]][,3]), "Min", min(window_sequence_list[[index]][,3]), "Avg", round(mean(window_sequence_list[[index]][,3])*100)/100),"\n")
}
data[[index]] <- nodes_calculation(blockinfo[[index]], window_sequence_list[[index]])
data[[index]] <- simple_merge(data[[index]], intersect_func=intersect_func)
data[[index]] <- calculate_transition(data[[index]], intersect_func=intersect_func)
nwindow[index] <- nrow(window_sequence_list[[index]])
indi <- sum(blockinfo[[index]][[1]][[1]])
nodes <- length(data[[index]])
}}
length(data[[1]])
z <- ignore_small_nodes(data[[index]], indi, nwindow[index], node_min_early, gap, intersect_func=intersect_func)
index
nwindow
indi
node_min_early
gap
intersect_func()
intersect_func
data[[1]][[1]]
indi
node_min
nwindow[index]
ignore_small_nodes(data[[index]], indi, nwindow[index], node_min, gap, intersect_func=intersect_func)
z <- ignore_small_nodes(data[[index]], indi, nwindow[index], node_min, gap, intersect_func=intersect_func)
length(z)
z1 <- ignore_small_nodes(data[[index]], indi, nwindow[index], node_min, 0, intersect_func=intersect_func)
length(z)
z1[[2]]
z1[[3]]
z1[[4]]
z1[[10]]
z1[[6]]
z1[[7]]
z1[[7]]
z1[[8]]
z1[[9]]
z1[[6]]
z1[[9]]
z1[[11]]
z1[[6]]
z1[[9]]
z1[[11]]
z1[[6]]
z1[[1]]
z1[[2]
]
z1[[1]]
z1[[1]]
z1[[2]]
z1[[5]]
source('C:/Users/pook/Desktop/R-Stuff/HaploBlocker/R/crossmerge.R')
z1[[7]]
z1[[3]]
z1[[7]]
z1[[12]]
z1[[7]]
z1[[12]]
z1[[7]]
z1[[8]]
z1[[7]]
z1[[3]]
z1[[7]]
z1[[12]]
z1[[3]]$haplos != z1[[7]]$haplos
